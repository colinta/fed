#!/usr/bin/env node
const fs = require('fs')
const EventEmitter = require('events')
const {exec, execSync} = require('child_process')

process.stdout.on('error', function (err) {
  if (err.code === 'EPIPE') {
    exec('stty echo', () => {
      process.exit(0)
    })
  }
})

function requireArg(name, value) {
  if (value == null) {
    throw Error(`Missing argument: ${name}`)
  }
}

class Rule {
  delim = ''
  pattern = ''
  replace
  args

  constructor(delim, pattern, replace, args) {
    this.delim = delim
    this.pattern = pattern
    this.replace = replace
    this.args = args
  }

  /**
   * Run before any lines are processed
   */
  before(state, options) {}

  /**
   * Run after all lines have processed.
   */
  after(state, options) {}

  explain() {
    return ''
  }
}

class LineRule extends Rule {
  /**
   * Run before every line
   */
  beforeEach(line, state, options) {}
  /**
   * Runs on every line, even if previous rules returned null/undefined
   */
  run(line, lineNo, state, options) {
    if (line != null) {
      return this.line(line, lineNo)
    }
  }
  /**
   * Should only run on lines that have text, even if the text is ''
   */
  line(line, lineNo) {}
  /**
   * Run after every line (or lines, if a rule returns multiple lines)
   */
  afterEach(line, state, options) {}
}

class DocumentRule extends Rule {
  /**
   * Runs on every rule, even if there are no lines.
   */
  run(documentLines, state, options) {
    if (documentLines.length) {
      return this.lines(documentLines, state, options)
    }
  }

  /**
   * lines is an array of [line, lineNo]
   */
  lines(documentLines, state, options) {}
}

/**
 * Performs a single substitution on every line that matches. Use gsub to replace
 * multiple substitutions per-line.
 *
 * When matching line numbers (':' delimiter), the entire line is replaced with the
 * matching text.
 *
 * The '`' delimiter can be used to match literal strings, all other delimiters
 * match using Regex.
 *
 * Usage:
 *     ssed sub/{pattern}/{replace}
 *     ssed sub`{search}`{replace}
 *     ssed sub:{line-number}:replace-lines
 *
 * Aliases:
 *     ssed s/{pattern}/{replace}
 *
 * @example using regex
 *     this is text | sub/this/that => that is text
 *
 * @example Using line numbers
 *     this
 *     is
 *     text | sub:1:that => that
 *                          is
 *                          text
 */
class SubstitutionRule extends LineRule {
  constructor(delim, pattern, replace) {
    replace ??= ''
    requireArg('pattern', pattern)

    super(delim, pattern, replace, [])

    if (delim === ':') {
      const lineRangeTest = toLineRangeTest(pattern)
      this.line = (line, lineNo) => {
        if (lineRangeTest(line, lineNo)) {
          return replace
        }
        return line
      }
    } else if (delim === '`') {
      this.line = line => line.replace(pattern, replace)
    } else {
      const regex = new RegExp(pattern)
      this.line = line => line.replace(regex, replace)
    }
  }

  explain() {
    return `Replace ${explainPattern(
      this.delim,
      this.pattern,
      'pattern',
    )} with '${this.replace}'`
  }
}

/**
 * Replaces every match with the substitution.
 *
 * The '`' delimiter can be used to match literal strings, all other delimiters
 * match using Regex.
 *
 * Does not support line numbers.
 *
 * Usage:
 *     ssed gsub/{pattern}
 *     ssed gsub`{search}
 *
 * Aliases:
 *     ssed g/{pattern}
 *
 * @example Using regex
 *     this is text | gsub/t/T => This is TexT
 *     this is text | g|t|T => This is Text
 */
class GlobalSubstitutionRule extends LineRule {
  constructor(delim, pattern, replace) {
    if (delim === ':') {
      throw Error(`'gsub' does not support line numbers (use 'sub')`)
    }

    replace ??= ''
    requireArg('pattern', pattern)
    super(delim, pattern, replace ?? '', [])

    if (delim === '`') {
      this.line = line => line.replace(pattern, replace)
    } else {
      const regex = new RegExp(pattern, 'g')
      this.line = line => line.replace(regex, replace)
    }
  }

  explain() {
    return `Replace all matches of ${explainPattern(
      this.delim,
      this.pattern,
      'pattern',
    )} with '${this.replace}'`
  }
}

/**
 * Only print the matching part of the line, or print the entire line if 'pattern'
 * doesn't match. (hint: Use `takeprint / tp` to only print matching lines)
 *
 * The '`' delimiter can be used to match literal strings, all other delimiters
 * match using Regex.
 *
 * Does not support line numbers.
 *
 * Usage:
 *     ssed take/{pattern}
 *     ssed take`{search}
 *
 * Aliases:
 *     ssed t/{pattern}
 *
 * @example Using regex
 *     this is text | take/t\w+ => this
 *     this is text | t/t\w+ => this
 *     how now      | take/t\w+ => how now
 */
class TakeRule extends LineRule {
  constructor(delim, pattern) {
    if (delim === ':') {
      throw Error(`'take' does not support line numbers`)
    }

    super(delim, pattern, '', [])

    if (delim === '`') {
      this.line = line => {
        if (line.includes(pattern)) {
          return pattern
        }

        return line
      }
    } else {
      const regex = new RegExp(pattern)
      this.line = line => {
        const match = line.match(regex)
        return match ? match[0] : line
      }
    }
  }

  explain() {
    return `If the line matches ${explainPattern(
      this.delim,
      this.pattern,
      'pattern',
    )}, only print the matching part of the line.`
  }
}

/**
 * Removes the matching part of the line, or print the entire line if 'pattern'
 * doesn't match.
 *
 * The '`' delimiter can be used to match literal strings, all other delimiters
 * match using Regex.
 *
 * Usage:
 *     ssed rm/{pattern}
 *     ssed rm`{pattern}
 *
 * Aliases:
 *     ssed r/{pattern}
 *
 * @example Using regex
 *     this is text | rm/^\w+ is/ => text
 */
class RemoveRule extends LineRule {
  constructor(delim, pattern) {
    if (delim === ':') {
      throw Error(`'rm' does not support line numbers`)
    }

    super(delim, pattern, '', [])

    if (delim === '`') {
      this.line = line => line.replace(pattern, '')
    } else {
      const regex = new RegExp(pattern)
      this.line = line => line.replace(regex, '')
    }
  }

  explain() {
    return `Remove ${explainPattern(
      this.delim,
      this.pattern,
      'pattern',
    )} from every line`
  }
}

/**
 * Only print lines that match 'pattern'.
 *
 * When matching line numbers, only the matching lines are printed. This works
 * identically to the 'take' command.
 *
 * Usage:
 *     ssed print/{pattern}
 *     ssed print:{line-number}
 *
 * Aliases:
 *     ssed p/{pattern}
 *     ssed p`{search}
 *
 * @example Using regex
 *     this
 *     is
 *     text | p/^t => this
 *                    text
 *
 * @example Using line numbers
 *     this
 *     is
 *     text | print:2-3 => is
 *                         text
 */
class PrintRule extends LineRule {
  check

  constructor(delim, pattern) {
    pattern ??= ''
    super(delim, pattern, '', [])

    if (delim === ':') {
      this.check = toLineRangeTest(pattern)
    } else if (delim === '`') {
      this.check = line => line.includes(pattern)
    } else {
      const regex = new RegExp(pattern)
      this.check = line => line.match(regex)
    }
  }

  line(line, lineNo) {
    return this.check(line, lineNo) ? line : undefined
  }

  explain() {
    return `Print ${explainPattern(this.delim, this.pattern, 'matching-lines')}`
  }
}

/**
 * Removes lines that match the pattern. Inverse of "print".
 *
 * Usage:
 *    ssed kill/{pattern}
 *    ssed kill:{line-number}
 *
 * Aliases:
 *    ssed k/{pattern}
 *    ssed !p/{pattern}
 *    ssed !print/{pattern}
 *
 * When matching line numbers, the matching lines are removed.
 *
 * @example Using regex
 *     this
 *     is
 *     some
 *     text | k/is => some
 *                    text
 *
 * @example Using line numbers
 *     this
 *     is
 *     text | kill:1 => is
 *                      text
 */
class KillRule extends LineRule {
  check

  constructor(delim, pattern) {
    super(delim, pattern, '', [])

    if (delim === ':') {
      this.check = toLineRangeTest(pattern)
    } else if (delim === '`') {
      this.check = line => line.includes(pattern)
    } else {
      const regex = new RegExp(pattern)
      this.check = line => line.match(regex)
    }
  }

  line(line, lineNo) {
    return this.check(line, lineNo) ? undefined : line
  }

  explain() {
    return `Remove ${explainPattern(
      this.delim,
      this.pattern,
      'matching-lines',
    )}`
  }
}

/**
 * Only prints unique lines. Default behaviour matches the entire line, but you can
 * specify a regular expression to only match part of the line. If the line doesn't
 * match, it isn't printed.
 *
 * Does not support line-numbers.
 *
 * Usage:
 *    ssed unique
 *    ssed unique/{pattern}
 *
 * Aliases:
 *    ssed uniq
 *
 * @example
 *     alice
 *     alice
 *     bob
 *     bob | uniq => alice
 *                   bob
 *
 * @example Using regex
 *     who is alice?
 *     what is alice?
 *     I don't know.
 *     do you know bob?
 *     does anyone know bob? | uniq/\w+\? => who is alice?
 *                                           do you know bob?
 */
class UniqueRule extends LineRule {
  part

  constructor(delim, pattern) {
    super(delim, pattern, '', [])

    if (delim === ':') {
      throw Error(`'uniq' does not support line numbers`)
    }

    if (delim === '`') {
      throw Error(`'uniq' does not support literal matches`)
    }

    if (pattern) {
      const regex = new RegExp(pattern)
      this.part = line => {
        const match = line.match(regex)
        return match ? match[0] : null
      }
    } else {
      this.part = line => line
    }

    const uniqueLines = new Set()
    this.line = line => {
      const match = this.part(line)
      if (match == null) {
        return null
      }

      if (!uniqueLines.has(match)) {
        uniqueLines.add(match)
        return line
      }
    }
  }

  explain() {
    if (this.pattern) {
      return `Only print lines that match ${explainPattern(
        this.delim,
        this.pattern,
        'pattern',
      )}. Uniqueness is determined by the matching part of the line. The entire line is printed.`
    }
    return 'Only print unique lines'
  }
}

/**
 * Trims whitespace from the line. Defaults to trimming whitespace on both sides,
 * but 'left' or 'right' can be specified to only trim on one side.
 *
 * Usage:
 *    ssed trim
 *    ssed trim:left
 *    ssed trim:right
 *
 * @example '|' indicates start and end of line
 *     |     line 1|
 *     |line 2     |
 *     |   line 3  | ssed trim => |line 1|
 *                                |line 2|
 *                                |line 3|
 *
 * @example
 *     |     line 1|
 *     |line 2     |
 *     |   line 3  | ssed trim:right => |     line 1|
 *                                      |line 2|
 *                                      |   line 3|
 */
class TrimRule extends LineRule {
  trim

  constructor(delim, pattern) {
    super(delim, pattern, '', [])
    if (delim === ':') {
      throw Error(`'trim' does not support line numbers`)
    }

    // Set the appropriate trim function based on the pattern
    switch (pattern) {
      case 'left':
        this.trim = line => line.replace(/^\s+/, '')
        break
      case 'right':
        this.trim = line => line.replace(/\s+$/, '')
        break
      case 'both':
      default:
        this.trim = line => line.trim()
        break
    }

    this.line = line => this.trim(line)
  }

  explain() {
    switch (this.pattern) {
      case 'left':
        return 'Trim whitespace from the left side of the line'
      case 'right':
        return 'Trim whitespace from the right side of the line'
      default:
        return 'Trim whitespace from both sides of the line'
    }
  }
}

/**
 * Surround each line with text.
 *
 * Usage:
 *    ssed surround/{prepend}/{append}
 *
 * @example
 *     1
 *     2
 *     3
 *     4 | 'surround:->:<-' => ->1<-
 *                             ->2<-
 *                             ->3<-
 *                             ->4<-
 */
class SurroundRule extends LineRule {
  prepend
  append

  constructor(delim, prepend, append) {
    super(delim, '', '', []) // pattern and replace are not used in this rule
    this.prepend = prepend
    this.append = append
  }

  line(line) {
    return this.prepend + line + this.append
  }

  explain() {
    return `Surround each line with '${this.prepend}' and '${this.append}'`
  }
}

/**
 * Prepends (prefix) each line with text.
 *
 * Usage:
 *    ssed prepend/{text}
 *
 * Aliases:
 *    ssed prefix/{text}
 *
 * @example
 *     1
 *     2
 *     3
 *     4 | prepend:'line ' => line 1
 *                            line 2
 *                            line 3
 *                            line 4
 */
class PrependRule extends SurroundRule {
  constructor(delim, prependText) {
    super(delim, prependText, '')
  }

  explain() {
    return `Prepend each line with '${this.prepend}'`
  }
}

/**
 * Append (suffix) each line with text.
 *
 * Usage:
 *    ssed append/{text}
 *
 * Aliases:
 *    ssed suffix/{text}
 *
 * @example
 *     1
 *     2
 *     3
 *     4 | append:' foo' => 1 foo
 *                          2 foo
 *                          3 foo
 *                          4 foo
 */
class AppendRule extends SurroundRule {
  constructor(delim, appendText) {
    super(delim, '', appendText)
  }

  explain() {
    return `Append each line with '${this.append}'`
  }
}

/**
 * Insert text after each matching line.
 *
 * Usage:
 *    ssed insert/{pattern}/{text}
 *
 * @example
 *     1
 *     2
 *     3
 *     4 | 'insert:%2:!!!' => ->1<-
 *                            ->2<-
 *                            ->3<-
 *                            ->4<-
 */
class InsertRule extends LineRule {
  check

  constructor(delim, pattern, text) {
    requireArg('pattern', pattern)
    requireArg('text', text)

    super(delim, pattern, text, [])

    if (delim === ':') {
      this.check = toLineRangeTest(pattern)
    } else if (delim === '`') {
      this.check = line => line.includes(pattern)
    } else {
      const regex = new RegExp(pattern)
      this.check = line => line.match(regex)
    }
  }

  line(line, lineNo) {
    if (this.check(line, lineNo)) {
      return [line, this.replace] // this.replace holds the text to be inserted
    }
    return line
  }

  explain() {
    return `After ${explainPattern(
      this.delim,
      this.pattern,
      'pattern',
    )} insert '${this.replace}'`
  }
}

/**
 * Commands to turn printing on and off based on a pattern or line number.
 *
 * on:     turn printing on at the matching line
 * after:  turn printing on after the matching line
 * off:    turn printing off at the matching line
 * toggle: printing starts on, toggles on matching lines
 *
 * Usage:
 *    ssed on/{pattern}
 *    ssed on:{line-number}
 *    ssed after/{pattern}
 *    ssed off/{pattern}
 *    ssed toggle/{pattern}
 *
 * @example
 *     a
 *     b
 *     c
 *     d
 *     e
 *     f
 *     g | on/b off/d after/f => b   # starts "off", is turned on by matching 'b'
 *                               c   # still "on", turned off by matching 'd'
 *                               g   # off until 'f', then turned on starting at next line
 */
class ControlPrintingRule extends LineRule {
  cmd
  check

  constructor(cmd, delim, pattern) {
    requireArg('pattern', pattern)

    super(delim, pattern, '', [])

    this.cmd = cmd
    if (delim === ':') {
      this.check = toLineRangeTest(pattern)
    } else if (delim === '`') {
      this.check = line => line.includes(pattern)
    } else {
      const regex = new RegExp(pattern)
      this.check = line => line.match(regex)
    }
  }

  beforeEach(line, state) {
    state.suppressedLine = null

    if (state.printOn == null) {
      if (this.cmd === 'on') {
        state.printOn = false
      } else if (this.cmd === 'off' || this.cmd === 'toggle') {
        state.printOn = true
      }
    }
  }

  run(line, lineNo, state) {
    if (
      this.cmd === 'on' &&
      state.suppressedLine != null &&
      this.check(state.suppressedLine, lineNo)
    ) {
      state.printOn = true
      line = state.suppressedLine
    } else if (
      this.cmd === 'on' &&
      line != null &&
      (state.printOn || this.check(line, lineNo))
    ) {
      state.printOn = true
    } else if (
      this.cmd === 'off' &&
      state.printOn &&
      this.check(line, lineNo)
    ) {
      state.printOn = false
    } else if (this.cmd === 'toggle' && this.check(line, lineNo)) {
      state.printOn = !state.printOn
    }

    if (state.printOn) {
      state.suppressedLine = null
      return line
    } else {
      state.suppressedLine ??= line
    }

    if (
      this.cmd === 'after' &&
      state.suppressedLine != null &&
      !state.printOn &&
      this.check(state.suppressedLine, lineNo)
    ) {
      state.printOn = true
    } else if (this.cmd === 'after' && this.check(line, lineNo)) {
      state.printOn = true
    }
  }

  explain() {
    const matchingLines = explainPattern(
      this.delim,
      this.pattern,
      'matching-lines',
    )

    if (this.cmd === 'on') {
      return `Printing starts off, and is turned on at ${matchingLines}`
    }

    if (this.cmd === 'off') {
      return `Printing starts on, and is turned off at ${matchingLines}`
    }

    if (this.cmd === 'toggle') {
      return `Printing starts on, and is toggled at ${matchingLines}`
    }

    // cmd === 'after'
    return `Printing starts off, and is turned on after ${matchingLines}`
  }
}

/**
 * Replaces the pattern with the nth group of the match. If no pattern is given,
 * the line is separated by whitespace and the nth column is printed.
 *
 * Does not support line-numbers.
 *
 * Usage:
 *    # for every line that matches pattern, replace the Nth regex group
 *    ssed 1/{pattern(group1)}
 *    ssed 2/{pattern(group1)(group2)}
 *    ssed …/{pattern(…)}
 *
 *    # print the first "column" (columns are separated by whitespace, quotes are
 *    # ignored)
 *    ssed 1
 *
 * @example
 *     text | 1/\w(\w+)$ => ext
 *     this is text | 2/(\w+) (\w+) (\w+) => is
 */
class GroupMatchRule extends LineRule {
  index

  constructor(index, delim, pattern) {
    super(delim, pattern, '', [])
    this.index = index

    if (delim === ':') {
      throw Error(`'${index}' does not support line numbers`)
    }

    if (delim === '`') {
      throw Error(`'${index}' does not support literal matches`)
    }

    if (!pattern) {
      this.line = line => {
        const match = line.split(/\s+/, index)
        return match.length >= index - 1 ? match[index - 1] : line
      }
    } else {
      const regex = new RegExp(pattern)
      this.line = line => {
        const match = line.match(regex)
        return match && match[index] ? match[index] : line
      }
    }
  }

  explain() {
    if (!this.pattern) {
      return `Print column #${this.index}, columns are separated by whitespace`
    }

    return `Replace ${explainPattern(
      this.delim,
      this.pattern,
      'pattern',
    )} with group #${this.index}`
  }
}

/**
 * A straightforward 'awk' feature: separate line on whitespace and print certain columns.
 *
 * Usage:
 *    # Use default separator (\s+) and print columns 1,3,2
 *    ssed cols//1,3,2
 *
 *    # Split lines by ':' and print columns 1 and 5
 *    # (columns will be joined with a space)
 *    ssed cols/:/1,5
 *
 *    # Same, but join columns using ':'
 *    ssed cols/:/1,5/:
 *
 * @example
 *     this    is    text | cols//2,1,3 => is this text
 *     1:bb:3:4:Z | cols/:/1,3,2 => 1 3 bb
 */
class ColumnsRule extends LineRule {
  columns
  joiner

  constructor(delim, pattern, columns, args) {
    pattern ??= ''
    super(delim, pattern, '', [])

    requireArg('columns', columns)

    if (delim === ':') {
      throw new Error(`'cols' does not support line numbers`)
    }

    this.columns = columns.split(',').map(Number)

    let splitter
    if (pattern && delim === '`') {
      splitter = pattern
    } else if (pattern) {
      splitter = new RegExp(pattern === '' ? /\s+/ : pattern)
    } else {
      splitter = /\s+/
    }

    this.joiner = args[0] ?? ' '

    this.line = line => {
      const parts = line.split(splitter)
      return this.columns.map(index => parts[index - 1] ?? '').join(this.joiner)
    }
  }

  explain() {
    let explanation = ''
    if (this.pattern) {
      explanation = `Split each line into columns using ${explainPattern(
        this.delim,
        this.pattern,
        'pattern',
      )}`
    } else {
      explanation = 'Split each line into columns by whitespace'
    }

    explanation += ` and print columns ${this.columns.join(', ')}`

    if (this.joiner) {
      explanation += ` joined by '${this.joiner}'`
    } else {
      explanation += ` joined by ' '`
    }

    return explanation
  }
}

class CombineRules extends LineRule {
  rules

  constructor(...rules) {
    super('', '', '', []) // Delim, pattern, replace, and args are not directly used in CombineRules
    this.rules = rules
  }

  before(state) {
    this.rules.forEach(rule => rule.before(state))
  }

  beforeEach(line, state) {
    this.rules.forEach(rule => rule.beforeEach(line, state))
  }

  run(line, lineNo, state) {
    return this.rules.reduce(
      (line, rule) => rule.run(line, lineNo, state),
      line,
    )
  }

  afterEach(line, state) {
    this.rules.forEach(rule => rule.afterEach(line, state))
  }

  after(state) {
    this.rules.forEach(rule => rule.after(state))
  }

  explain() {
    return this.rules.map(rule => rule.explain()).join('\n')
  }
}

function toLineRule([cmd, pattern, replace, rest, delim]) {
  let rule
  switch (cmd) {
    case 'sub':
    case 's':
      rule = new SubstitutionRule(delim, pattern, replace)
      break
    case 'gsub':
    case 'g':
      rule = new GlobalSubstitutionRule(delim, pattern, replace)
      break
    case 'take':
    case 't':
      rule = new TakeRule(delim, pattern)
      break
    case 'rm':
    case 'r':
      rule = new RemoveRule(delim, pattern)
      break
    case 'print':
    case 'p':
      rule = new PrintRule(delim, pattern)
      break
    case 'takeprint':
    case 'pt':
    case 'tp': {
      const take = new TakeRule(delim, pattern)
      const print = new PrintRule(delim, pattern)
      rule = new CombineRules(take, print)
      break
    }
    case 'rmprint':
    case 'pr':
    case 'rp': {
      const remove = new RemoveRule(delim, pattern)
      const print = new PrintRule(delim, pattern)
      rule = new CombineRules(remove, print)
      break
    }
    case 'kill':
    case 'k':
    case '!p':
    case '!print':
      rule = new KillRule(delim, pattern)
      break
    case 'uniq':
    case 'unique':
      rule = new UniqueRule(delim, pattern)
      break
    case 'trim':
      rule = new TrimRule(delim, pattern)
      break
    case 'prepend':
    case 'prefix':
      rule = new PrependRule(delim, pattern)
      break
    case 'append':
    case 'suffix':
      rule = new AppendRule(delim, pattern)
      break
    case 'surround':
      rule = new SurroundRule(delim, pattern, replace)
      break
    case 'insert':
      rule = new InsertRule(delim, pattern, replace)
      break
    case 'on':
    case 'off':
    case 'after':
    case 'toggle':
      rule = new ControlPrintingRule(cmd, delim, pattern)
      break
    case 'cols':
      rule = new ColumnsRule(delim, pattern, replace, rest)
      break
    default:
      if (cmd.match(/^\d+$/)) {
        const index = parseInt(cmd)
        rule = new GroupMatchRule(index, delim, pattern)
      }
      break
  }

  return rule
}

class DocumentSortRule extends DocumentRule {
  ascending

  constructor(pattern, replace, ascending = true) {
    super('', pattern, replace, []);

    const regex = pattern && new RegExp(pattern);
    this.ascending = ascending;
    this.lines = (documentLines) =>
      documentLines
      .map(([line]) => line)
      .toSorted((a, b) => {
        if (regex) {
          let aMatch = a.match(regex);
          let bMatch = b.match(regex);
          if (aMatch && bMatch) {
            if (this.replace) {
              aMatch = a.replace(regex, this.replace);
              bMatch = b.replace(regex, this.replace);
            } else {
              aMatch = aMatch[0];
              bMatch = bMatch[0];
            }

            return aMatch.localeCompare(bMatch) * (this.ascending ? 1 : -1);
          } else {
            return 0;
          }
        }

        return a.localeCompare(b) * (this.ascending ? 1 : -1);
      });
  }

  explain() {
    const leading = `Sort lines in${this.ascending ? '' : ' reverse'} alphabetical order`
    if (this.pattern && this.replace) {
      return `${leading} based on the matching part of ${explainPattern(this.delim, this.pattern, 'pattern')} after replacing with '${this.replace}'`;
    } else if (this.pattern) {
      return `${leading} based on the matching part of ${explainPattern(this.delim, this.pattern, 'pattern')}`;
    } else {
      return leading;
    }
  }
}

class DocumentSortNumericRule extends DocumentRule {
  ascending

  constructor(pattern, replace, ascending = true) {
    super('', pattern, replace, []);

    const regex = pattern && new RegExp(pattern);
    this.ascending = ascending;
    this.lines = (documentLines) =>
      documentLines
        .map(([line]) => line)
      .toSorted((a, b) => {
        if (regex) {
          let aMatch = a.match(regex)
          let bMatch = b.match(regex)
          if (aMatch && bMatch) {
            if (replace) {
              a = a.replace(regex, replace)
              b = b.replace(regex, replace)
            } else {
              a = aMatch[0]
              b = bMatch[0]
            }
          } else {
            return 0
          }
        }

        let numberA = a.replace(/^.*?(-?\b\d+(\.\d*)?).*$/, '$1')
        if (numberA.isNaN()) {
          numberA = 0
        }

        let numberB = b.replace(/^.*?(-?\b\d+(\.\d*)?).*$/, '$1')
        if (numberB.isNaN()) {
          numberB = 0
        }

        return (Number(numberA) - Number(numberB)) * (ascending ? 1 : -1)
      });
  }

  explain() {
    const leading = `Sort lines in${this.ascending ? '' : ' reverse'} numeric order`
    if (this.pattern && this.replace) {
      return `${leading} based on the matching part of ${explainPattern(this.delim, this.pattern, 'pattern')} after replacing with '${this.replace}'`;
    } else if (this.pattern) {
      return `${leading} based on the matching part of ${explainPattern(this.delim, this.pattern, 'pattern')}`;
    } else {
      return leading;
    }
  }
}

class DocumentReverseRule extends DocumentRule {
  constructor() {
    super('', '', '', []);
  }

  lines(documentLines) {
    return documentLines.toReversed();
  }

  explain() {
    return "Reverse the order of all lines";
  }
}

class DocumentLineNumbersRule extends DocumentRule {
  minWidth

  constructor(pattern, replace) {
    super('', pattern, null, []);

    if (replace) {
      const minWidth = replace ? Number(replace) : 0
      if (minWidth.isNaN()) {
        throw Error(`Invalid width '${replace}', expected a number`)
      } else {
        this.minWidth = minWidth
        this.pad = '0'
      }
    } else {
      this.pad = ' '
      this.minWidth = 0
    }
  }

  lines(documentLines) {
    const max = documentLines.length.toString().length;
    return documentLines.map(([line, lineNo]) => {
      let lineNoStr = lineNo.toString();
      let pad;
      if (this.replace) {
        pad = '0'.repeat(Math.max(Number(this.replace), max) - lineNoStr.length);
      } else {
        pad = ' '.repeat(max - lineNoStr.length);
      }
      const joiner = this.pattern ?? ':';
      return pad + lineNoStr + joiner + line;
    });
  }

  explain() {
    const leading = `Add line numbers to each line with '${this.pattern ?? ':'}' as separator`
    if (this.minWidth) {
      return ` and padding with '${this.replace ? '0' : 'spaces'}'`;
    }

    return leading
  }
}

/**
 * Similar to the line substitution rule, but the substituted text is "spread"
 * across all the lines that match.
 */
class DocumentSubstituteLinesRule extends DocumentRule {
  constructor(delim, pattern, replace) {
    requireArg('pattern', pattern)

    super(delim, pattern, replace, [])

    let check
    if (delim === ':') {
      check = toLineRangeTest(pattern)
    } else if (delim === '`') {
      check = line => line.includes(pattern)
    } else {
      const regex = new RegExp(pattern)
      check = line => line.match(regex)
    }

    const replaceLines = replace.split('\n')
    this.lines = documentLines => {
      const matchedLineNumbers = []
      // find all the lines that match, put into matchedLineNumbers
      // if (matchedLineNumbers >= replaceLines) {
      //   remove extra matched lines
      // } else (matchedLineNumbers < replaceLines) {
      //   add matched lines 1:1 with replaceLines until we
      //   get to the last matched line, then insert all
      //   remaining lines
      // }
      documentLines.forEach(([line, lineNo]) => {
        if (check(line, lineNo)) {
          matchedLineNumbers.push(lineNo)
        }
      })

      return documentLines.flatMap(([line, lineNo]) => {
        if (matchedLineNumbers.length && matchedLineNumbers[0] === lineNo) {
          matchedLineNumbers.shift()
          if (matchedLineNumbers.length === 0) {
            return replaceLines
          } else {
            const nextLine = replaceLines.shift()
            if (nextLine == null) {
              return []
            } else {
              return [nextLine]
            }
          }
        }

        return [line]
      })
    }
  }

  explain() {
    return `Substitute lines matching pattern '${explainPattern(this.delim, this.pattern, 'pattern')}' with provided replacement lines`;
  }
}

/**
 * Similar to the line substitution rule, but the substituted text is "spread"
 * across all the lines that match.
 */
class DocumentExecRule extends DocumentRule {
  constructor() {
    super('', '', '', [])
  }

  lines(documentLines, _, options) {
    const input = documentLines.map(([line]) => line).join('\n')

    if (options.dryRun) {
      return input.split('\n')
    }

    if (input) {
      return execSync(input).toString('utf-8').split('\n')
    }

    return []
  }

  explain() {
    return "Execute entire document as a shell script and replace with the command output";
  }
}

class DocumentSurroundRule extends DocumentRule {
  prependLines
  appendLines

  constructor(prependText, appendText) {
    super('', '', '', []);

    this.prependLines = prependText === '' ? [] : prependText.split('\n');
    this.appendLines = appendText === '' ? [] : appendText.split('\n');
  }

  lines(documentLines) {
    const lines = documentLines.map(([line]) => line)
    return [
      ...this.prependLines,
      ...lines,
      ...this.appendLines,
    ];
  }

  explain() {
    let explanation = '';
    if (this.prependLines.length) {
      explanation += `Prepend document with '''\n${this.prependLines.join('\\n')}\n'''`;
    }

    if (this.prependLines.length && this.appendLines.length) {
      explanation += ' and append '
    } else if (this.appendLines.length) {
      explanation += 'Append '
    }

    if (this.appendLines.length) {
      explanation += `document with '''\n${this.appendLines.join('\\n')}\n'''`;
    }

    return explanation || 'No changes made to the document';
  }
}

class DocumentJoinLinesRule extends DocumentRule {
  joiner

  constructor(joiner) {
    super('', '', '', []);
    this.joiner = joiner || ' ';
  }

  lines(documentLines) {
    return [documentLines.map(([line]) => line).join(this.joiner)];
  }

  explain() {
    return `Join all lines into a single line using '${this.joiner}' as the separator`;
  }
}

class DocumentCountRule extends DocumentRule {
  constructor() {
    super('', '', '', []);
  }

  lines(documentLines) {
    return [[documentLines.length.toString()]];
  }

  explain() {
    return "Count the number of lines in the document and replace the content with the count";
  }
}

class DocumentLineRules extends DocumentRule {
  lineRules

  constructor(lineRules) {
    super('', '', '', [])
    this.lineRules = lineRules
  }

  lines(documentLines, _, options) {
    const state = resetState()

    for (const lineRule of this.lineRules) {
      lineRule.before?.(state)
    }

    const inputLines = documentLines.map(([line]) => line)
    const isLastLineBlank = inputLines.at(-1) === ''
    if (isLastLineBlank) {
      inputLines.pop()
    }

    const retLines = []
    processLines(state, true, this.lineRules, options, retLines, inputLines)

    for (const lineRule of this.lineRules) {
      lineRule.after?.(state)
    }

    if (isLastLineBlank) {
      retLines.push('')
    }

    return retLines
  }

  explain() {
    return this.lineRules.map(rule => rule.explain()).join('\n')
  }
}

function toDocumentRule([cmd, pattern, replace, rest, delim]) {
  switch (cmd) {
    case 'count':
      return new DocumentCountRule()
    case '!sort':
    case 'sort':
      return new DocumentSortRule(pattern, replace, !cmd.startsWith('!'))
    case '!sortn':
    case 'sortn':
      return new DocumentSortNumericRule(pattern, replace, !cmd.startsWith('!'))
    case 'reverse':
      return new DocumentReverseRule()
    case 'begin':
    case 'border':
      return new DocumentSurroundRule(pattern ?? '', replace ?? '')
    case 'end':
      return new DocumentSurroundRule('', pattern)
    case 'line':
    case 'lines':
      return new DocumentLineNumbersRule(pattern, replace)
    case 'join':
      return new DocumentJoinLinesRule(pattern)
    case 'sl':
    case 'sublines':
      return new DocumentSubstituteLinesRule(delim, pattern, replace)
    case 'exec':
      return new DocumentExecRule()
    case 'help':
      help()
      process.exit(0)
    case 'docsurround':
      console.error('`' + cmd + '` is deprecated, use `border` instead')
      process.exit(1)
    case 'docprepend':
    case 'docprefix':
      console.error('`' + cmd + '` is deprecated, use `begin` instead')
      process.exit(1)
    case 'docappend':
    case 'docsuffix':
      console.error('`' + cmd + '` is deprecated, use `after` instead')
      process.exit(1)
    default:
      console.error('Unknown command: ' + cmd)
      process.exit(1)
  }
}

function escapeRegex(pattern) {
  return pattern.replaceAll('/', '\\/')
}

function escapeLiteral(pattern) {
  return pattern.replaceAll("'", "\\'")
}

function explainPattern(delim, pattern, text) {
  if (delim === ':') {
    return _toLineRangeTest(pattern, 'explain')
  }

  if (delim === '`') {
    if (text === 'pattern') {
      return `'${escapeLiteral(pattern)}'`
    } else if (text === 'matching-lines') {
      return `lines that match '${escapeLiteral(pattern)}'`
    }
  }

  if (text === 'pattern') {
    return `/\\${escapeRegex(pattern)}/`
  } else if (text === 'matching-lines') {
    return `lines that match /\\${escapeRegex(pattern)}/`
  }

  return `/\\${escapeRegex(pattern)}/`
}

function toLineRangeTest(pattern) {
  return _toLineRangeTest(pattern, 'run')
}

function _toLineRangeTest(pattern, job) {
  const matchModulo = /%\s*\d+\s*(-\s*\d+)?/
  const matchRange = /\d+\s*-\s*\d+|-\s*\d+|\d+\s*-|\d+/
  const valid = new RegExp(
    `^\*|(${matchModulo.source}|${matchRange.source})(\s*,\s*((${matchModulo.source}|${matchRange.source})))*$`,
  )
  if (!pattern.match(/^(\*|)$/)) {
    const allowed = [
      '',
      '* (all lines)',
      '$start-$stop (line range)',
      '$start-, -$stop (starting at line, ending at line)',
      '%$frequency (every Nth line)',
      '%$frequency-$offset (every Nth line minus offset)',
      '$range1, $range2 [, $range3] (multiple ranges)',
    ]
    throw Error('Invalid line range pattern, expected:' + allowed.join('\n - '))
  }

  if (!pattern || pattern === '*') {
    if (job === 'explain') {
      return 'all lines'
    }

    return () => true
  }

  if (pattern.includes(',')) {
    const rules = pattern.split(',').map(rule => toLineRangeTest(rule, job))
    if (job === 'explain') {
      return `(${rules.join(' or ')})`
    }

    return (line, lineNo) => rules.some(fn => fn(line, lineNo))
  }

  if (pattern.startsWith('%')) {
    let modulus = pattern.slice(1)
    if (modulus.includes('-')) {
      const [mod, offset] = modulus.split('-', 2).map(Number)
      if (job === 'explain') {
        return `every ${mod}-th - ${offset} line`
      }

      return (_, lineNo) => (lineNo + offset) % mod === 0
    } else {
      if (job === 'explain') {
        return `every ${modulus}-th line`
      }

      return (_, lineNo) => lineNo % Number(modulus) === 0
    }
  }

  if (pattern.includes('-')) {
    const [start, stop] = pattern.split('-', 2).map((number, index) => {
      if (number === '' && index === 0) {
        return 1
      } else if (number === '' && index === 1) {
        return Infinity
      } else {
        return Number(number)
      }
    })

    if (job === 'explain') {
      return start === 1 && stop === Infinity
        ? 'all lines'
        : start === 1
        ? `all lines up to ${stop}`
        : stop === Infinity
        ? `lines from ${start} to end`
        : `lines from ${start} to ${stop}`
    }

    return (_, lineNo) => lineNo >= start && lineNo <= stop
  }

  if (job === 'explain') {
    return `line ${Number(pattern)}`
  }

  return (_, lineNo) => lineNo === Number(pattern)
}

function lineStream(inputStream, transform = undefined) {
  const stdin = new EventEmitter()
  let buffer = ''
  let closed = false

  function emit(line) {
    if (closed) {
      return
    }

    if (transform) {
      line = transform(line)
    }

    if (line !== undefined) {
      stdin.emit('line', line)
    }
  }

  inputStream.on('open', function () {
    stdin.emit('open')
  })
  inputStream.on('data', function (chunk) {
    buffer += chunk
    const lines = buffer.split('\n')
    buffer = lines.pop()
    lines.forEach(line => emit(line))
  })

  inputStream.on('end', () => {
    emit(buffer)
    let autoclose = true
    function keepOpen() {
      autoclose = false
    }
    function close() {
      stdin.emit('close')
    }
    stdin.emit('end', keepOpen, close)
    if (autoclose) {
      close()
    }
  })

  inputStream.resume()
  inputStream.setEncoding('utf-8')

  stdin.pause = inputStream.pause.bind(inputStream)
  stdin.close = () => {
    closed = true
    inputStream.pause()
  }
  stdin.pipe = transform => {
    return lineStream(stdin, transform)
  }

  return stdin
}

function parseOption(options, arg, args) {
  let option
  if (arg.startsWith('--')) {
    ;[option] = arg.slice(2).match(/^([\w-]+)/) ?? [option]
  } else if (arg.startsWith('-')) {
    ;[option] = arg.slice(1).match(/^(\w+)/) ?? [option]
    return option.split('').map(opt => parseOption(options, `--${opt}`, args))
  } else {
    return
  }

  switch (option) {
    case 'h':
    case 'help': {
      help()
      process.exit(0)
    }
    case 'no-color':
    case 'color': {
      return {
        color: option === 'color',
      }
    }
    case 'n':
    case 'no-dry-run':
    case 'dry-run': {
      return {
        dryRun: option === 'dry-run',
      }
    }
    case 'no-diff':
    case 'diff': {
      return {
        diff: option === 'diff',
      }
    }
    case 'no-interactive':
    case 'interactive': {
      return {
        interactive: option === 'interactive',
      }
    }
    case 'no-write':
    case 'write': {
      const [, writeToFile] = arg.split('=', 2)

      return {
        write: option === 'write',
        diff: option === 'write',
        writeToFile,
      }
    }
    case 'no-input':
      return {inputFrom: 'stdin', input: process.stdin}
    case 'ls':
      return {inputFrom: 'ls', input: null}
    case 'input': {
      let file
      if (arg.match(/^--input=/)) {
        ;[, file] = arg.split('=', 2)
      } else {
        file = args.shift()
      }

      const fileNames = file.split(',')
      const prevFiles =
        options.inputFrom === 'files'
          ? options.input
          : options.inputFrom === 'file'
          ? [options.input]
          : []
      const files = [...prevFiles, ...fileNames].map(file => {
        if (fs.existsSync(file)) {
          return file
        } else {
          throw Error(`File does not exist: ${file}`)
        }
      })
      if (files.length === 0) {
        return {
          inputFrom: 'stdin',
          input: null,
        }
      } else if (files.length === 1) {
        return {
          inputFrom: 'file',
          input: files[0],
        }
      } else {
        return {
          inputFrom: 'files',
          input: files,
        }
      }
      break
    }
    default:
      throw Error(`Invalid option: ${option}`)
  }
}

function processLines(
  state,
  hasDocumentRules,
  lineRules,
  options,
  lines,
  linesBuffer,
) {
  for (const line of linesBuffer) {
    state.lineNumber += 1

    for (const lineRule of lineRules) {
      lineRule.beforeEach?.(line, state)
    }

    let mappedLines = [line]
    for (const lineRule of lineRules) {
      if (mappedLines.length === 0) {
        mappedLines = [null]
      }

      mappedLines = mappedLines.flatMap(line => {
        let nextLines = lineRule.run(line, state.lineNumber, state)
        if (nextLines == null) {
          return []
        }

        if (Array.isArray(nextLines)) {
          return nextLines.flatMap(line => line.split('\n'))
        }

        return nextLines.split('\n')
      })
    }

    for (const lineRule of lineRules) {
      mappedLines.forEach(line => {
        lineRule.afterEach?.(line, state)
      })
    }

    if (mappedLines.length > 0) {
      if (!options.diff && !hasDocumentRules) {
        mappedLines.forEach(line => options.print(line))
      } else {
        lines.push(...mappedLines)
      }
    }
  }
}

function main(args, options = {}) {
  options = {
    input: process.stdin,
    inputFrom: 'stdin',
    interactive: false,
    write: false,
    writeToFile: null,
    diff: false,
    diffHeader: '',
    diffContext: 3, // number of lines to print before and after diffs
    color: process.stdout.isTTY,
    print: (line, nl = true) => {
      process.stdout.write(line + (nl ? '\n' : ''))
    },
    error: (line, nl = true) => {
      process.stderr.write(line + (nl ? '\n' : ''))
    },
    ...options,
  }

  let lineRules = []
  const documentRules = []

  const argsCopy = [...args]
  const rules = []
  let arg
  while ((arg = argsCopy.shift()) != null) {
    const option = parseOption(options, arg, argsCopy)
    if (option !== undefined) {
      options = {...options, ...option}
    } else {
      rules.push(arg)
    }
  }

  // inputFrom: 'stdin' => parse stdin only (`<file ssed`)
  // inputFrom: 'file' => input: list of files (`ssed --input=file1,file2`)
  // inputFrom: 'ls' => read filenames from stdin (`ssed --input` - or `ssed --ls`)
  if (options.inputFrom === 'ls' || options.inputFrom === 'files') {
    function next(file) {
      main(rules, {
        ...options,
        inputFrom: 'file',
        input: file,
      }).on('open', () => {
        if (!options.diff) {
          options.print(yellow(`ssed: ${file}`))
        }
      })
    }

    if (options.inputFrom === 'ls') {
      const stdin = lineStream(process.stdin)
      // treat stdin as list of files

      stdin.on('line', file => {
        next(file)
      })
    } else {
      options.input.forEach(next)
    }

    return
  }

  if (options.inputFrom === 'file') {
    options.diffHeader = `diff ${options.input}
--- ${options.input}
+++ ssed ${args.map(escapeShell).join(' ')}`

    const file = options.input
    if (options.write && !options.writeToFile && file !== process.stdin) {
      options.writeToFile = file
    } else if (options.writeToFile) {
      options.writeToFile = options.writeToFile.replace('%', file)
    }

    options.input = fs.createReadStream(file)
  }

  for (const rule of rules) {
    const parsed = parseRuleArgs(rule)

    let lineRule, documentRule
    if ((lineRule = toLineRule(parsed))) {
      lineRules.push(lineRule)
    } else if ((documentRule = toDocumentRule(parsed))) {
      if (lineRules.length) {
        documentRules.push(new DocumentLineRules(lineRules))
        lineRules = []
      }

      documentRules.push(documentRule)
    } else {
      throw Error(`Invalid rule: ${rule}`)
    }
  }

  if (lineRules.length && documentRules.length) {
    documentRules.push(new DocumentLineRules(lineRules))
    lineRules = []
  }

  const inputStream = lineStream(options.input)
  const originalLines = []
  let lines = []

  // if (
  //   we only have line rules,
  //   no document rules,
  //   and we're not diffing the output
  // ), then: we perform a "stream edit".
  //
  // 1. create a state for the line rules
  // 2. don't store the output in lines
  // 3. output immediately
  const state = resetState()

  for (const lineRule of lineRules) {
    lineRule.before?.(state)
  }

  let linesBuffer = []
  return inputStream
    .on('line', line => {
      const original = line
      originalLines.push(original)

      linesBuffer.push(line)
      // special handling for blank lines – if the last line is blank we skip it
      if (line === '') {
        return
      }

      processLines(
        state,
        documentRules.length > 0,
        lineRules,
        options,
        lines,
        linesBuffer,
      )

      linesBuffer = []
    })
    .on('end', (keepOpen, close) => {
      if (linesBuffer.length === 1) {
        if (!options.diff && documentRules.length === 0) {
          options.print('')
        } else {
          state.lineNumber += 1
          lines.push('')
        }
      } else if (linesBuffer.length) {
        processLines(
          state,
          documentRules.length > 0,
          lineRules,
          options,
          lines,
          linesBuffer,
        )
      }

      for (const lineRule of lineRules) {
        lineRule.after?.(state)
      }

      const isLastLineBlank = lines.at(-1) === ''
      if (isLastLineBlank) {
        lines.pop()
      }

      for (const documentRule of documentRules) {
        const state = resetState()
        documentRule.before(state, options)

        const linesWithNumbers = lines.map((line, index) => [line, index + 1])
        lines = documentRule.run(linesWithNumbers, state, options)
        documentRule.after(state, options)
      }

      const finalLines = lines ?? []
      if (isLastLineBlank) {
        finalLines.push('')
      }

      if (options.diff) {
        const linesDiff = diff(originalLines, finalLines)
        const hasDiff = !(
          linesDiff.length === 1 && linesDiff[0].type === 'same'
        )
        if (hasDiff) {
          options.print(yellow(options.diffHeader, options.color))

          let inputLineNumber = 1
          let outputLineNumber = 1
          let didPrintNumbers = false
          function printLineNumbers(inputLineNumber, outputLineNumber) {
            if (!didPrintNumbers) {
              options.print(
                magenta(
                  `@@ -${inputLineNumber} +${outputLineNumber} @@`,
                  options.color,
                ),
              )

              didPrintNumbers = true
            }
          }

          linesDiff.forEach((entry, index) => {
            if (!entry.lines.length) {
              return
            }

            if (entry.type === 'same') {
              if (index === 0) {
                didPrintNumbers = false

                const printLines = entry.lines.slice(
                  Math.max(entry.lines.length - 3, 0),
                )
                inputLineNumber += entry.lines.length - printLines.length
                outputLineNumber += entry.lines.length - printLines.length
                printLineNumbers(inputLineNumber, outputLineNumber)
                printLines.forEach(line => options.print(' ' + line))
                inputLineNumber += printLines.length
                outputLineNumber += printLines.length
              } else if (index === linesDiff.length - 1) {
                const printLines = entry.lines.slice(0, 4)
                printLineNumbers(inputLineNumber, outputLineNumber)
                inputLineNumber += entry.lines.length - printLines.length
                outputLineNumber += entry.lines.length - printLines.length
                printLines.forEach(line => options.print(' ' + line))
                inputLineNumber += printLines.length
                outputLineNumber += printLines.length
              } else if (entry.lines.length <= 5) {
                entry.lines.forEach(line => options.print(' ' + line))
                inputLineNumber += entry.lines.length
                outputLineNumber += entry.lines.length
              } else {
                didPrintNumbers = false

                const beforeLines = entry.lines.slice(0, 3)
                const afterLines = entry.lines.slice(
                  Math.max(entry.lines.length - 3, 0),
                )
                beforeLines.forEach(line => options.print(' ' + line))
                inputLineNumber += entry.lines.length - afterLines.length
                outputLineNumber += entry.lines.length - afterLines.length
                printLineNumbers(inputLineNumber, outputLineNumber)
                afterLines.forEach(line => options.print(' ' + line))
              }

              return
            }

            entry.lines.forEach(line => {
              printLineNumbers(inputLineNumber, outputLineNumber)

              if (entry.type === 'added') {
                outputLineNumber += 1
                options.print(green(`+${line}`, options.color))
              } else if (entry.type === 'removed') {
                inputLineNumber += 1
                options.print(red(`-${line}`, options.color))
              }
            })
          })

          if (options.write) {
            if (options.interactive) {
              if (!process.stdin.isTTY) {
                options.error(
                  red(
                    `Cannot run interactively – input is coming from stdin`,
                    options.color,
                  ),
                )
                process.exit(1)
              }

              options.print(
                yellow(
                  `Write changes to ${options.writeToFile}? [Yn] `,
                  options.color,
                ),
                false,
              )
              keepOpen()

              const stdin = lineStream(process.stdin)
              stdin.on('line', line => {
                if (line === '' || line === 'y' || line === 'yes') {
                  if (options.dryRun) {
                    options.error(
                      yellow(`Dry Run: ${options.writeToFile}`, options.color),
                    )
                  } else {
                    writeLinesToFile(finalLines, options.writeToFile)
                  }
                } else if (line === 'n') {
                  options.error(
                    yellow(`Skipping ${options.writeToFile}`, options.color),
                  )
                } else {
                  options.error(
                    red(`Unknown response '${line}'. Aborting`, options.color),
                  )
                  process.exit(1)
                }
                stdin.close()
                close()
              })
            } else {
              if (options.dryRun) {
                options.error(
                  yellow(`Dry Run: ${options.writeToFile}`, options.color),
                )
              } else {
                writeLinesToFile(finalLines, options.writeToFile)
              }
            }
          }
        }
      } else {
        for (const line of finalLines) {
          options.print(line)
        }
      }
    })
}

function delimiterTestFn(delim) {
  if (delim === '{' || delim === '}') {
    return char => /[\{\}]/.test(char)
  }

  if (delim === '[' || delim === ']') {
    return char => /[\[\]]/.test(char)
  }

  if (delim === '(' || delim === ')') {
    return char => /[\(\)]/.test(char)
  }

  if (delim === '<' || delim === '>') {
    return char => /[<>]/.test(char)
  }

  return char => char === delim
}

function split(str, delim) {
  const test = delimiterTestFn(delim)
  const args = []
  let buffer = ''
  let isEscaped = false
  for (const char of str) {
    if (isEscaped) {
      if (char !== delim) {
        buffer += '\\'
      }
      buffer += char
      isEscaped = false
      continue
    }

    if (char === '\\') {
      isEscaped = true
      continue
    }

    if (test(char)) {
      args.push(buffer)
      buffer = ''
    } else {
      buffer += char
    }
  }

  if (isEscaped) {
    buffer += '\\'
  }

  if (buffer.length) {
    args.push(buffer)
  }

  return args
}

function unescape(str) {
  return str.replace(/\\(.)/g, (_, char) => {
    if (char === 'n') {
      return '\n'
    }
    if (char === 't') {
      return '\t'
    }
    return `\\${char}`
  })
}

function parseRuleArgs(rule) {
  const command = rule.match(/^(!?\w+\b|\d+)(.)/)
  if (!command) {
    const [simpleCommand] = rule.match(/^!?(\w+\b|\d+)$/) ?? []
    if (!simpleCommand) {
      throw Error(`Invalid rule: ${rule}`)
    }
    return [simpleCommand, null, null, []]
  }

  const [cmd, delim] = [command[1], command[2]]
  const argsString = rule.slice(command[0].length)
  const splitArgs = split(argsString, delim)
  const [pattern, replace, ...rest] = splitArgs.map(unescape)

  return [cmd.toLowerCase(), pattern, replace, rest, delim]
}

function help() {
  process.stderr.write(`Usage:
  ssed [options] [rules]

About
-----
    ssed is an alternative to 'sed'. Not a drop-in replacement, but used for
    similar tasks. I wanted more familiar and modern Regex support, and have
    kept adding more functions as ssed became more and more my go-to text
    manipulation tool.

    Line rules transform on a line-by-line basis and, if only line rules are
    employed, support STDIN streaming.

    Document rules transform the entire document. STDIN is read to completion
    before document rules are executed.

    If the last line is blank, it is ignored.

Options
-------
  --diff                       Only show differences
  --no-diff                    Do not show differences

  --color                      Enable ANSI colors (true if stdout is a TTY)
  --no-color                   Disable ANSI colors

  --ls                         Read file names from standard input (\`ls | ssed --ls\`)

  --input=fromfile             Use 'fromfile' as input
  aka --input fromfile

  --input=fromfile1,fromfile2  Run against multiple files.
  aka --input fromfile1 --input fromfile2

  --write                      Write each changed file in place.
  --write=tofile               Provide a destination file name.
  --write=%.backup             '\%' is replaced with the input file.
  --no-write                   Do not write each changed file in place.

  --interactive                Ask before writing the file
  --no-interactive             Do not ask before writing the file

  --dry-run (-n)               Show which files would be affected.
  --no-dry-run                 Do not show which files would be affected.

Line Rules
----------
Line rules operate on every line. Commands 'on', 'after' and 'off' share the on/off state.

  s/search/replace (aka sub/…/…)   Replace the first instance of 'search' with 'replace'
  g/search/replace (aka gsub/…/…)  Replace every instance of 'search' with 'replace'
  t/pattern (aka take/…)           Only print the matching part of the line, or print the entire line if 'pattern' doesn't match
  r/pattern (aka rm/…)             Remove the matching part of the line, or print the entire line if 'pattern' doesn't match
  1/pattern                        Only print the first group of the match
  1                                Only print the first "column" (columns are separated by whitespace)
  cols/pattern/columns             Split the line by 'pattern' (default is /\\s+/) and print columns
                                   - columns can be separated by commas
                                   - columns are joined by ' '
  cols/pattern/columns/joiner      - columns are joiner by $joiner

  on/pattern                       Start printing on the line where 'pattern' is matched
  off/pattern                      Stop printing on the line where 'pattern' is matched
  after/pattern                    Start printing on the line *after* 'pattern' is matched
  toggle/pattern                   Turn printing off at the matching line, then off, then on...

  p/pattern (aka print/…)          Only print lines that match 'pattern'
  k/pattern (aka kill/…)           Do not print lines that match 'pattern'
  !p/pattern (aka !print/…)        Alias for k/kill because I can't remember one (k) and always remember the other (p)

  prepend/text (aka prefix/…)
  append/text (aka suffix/…)       Adds text to the beginning (prepend) or end (append) of the line
  surround/prefix/suffix

  uniq (aka unique)                Only print unique lines
  uniq/pattern                     Only print matching lines, and only unique matches (uniqueness is determined by the matching regex)

Document Rules
--------------
  sublines/pattern/replace            For every line that matches, insert one line from replace. Remaining lines will
       (aka sl/…)                     be inserted into the last matched line. Does not do regex replacement.

  sort  sort/pattern                  Sort the lines alphabettically using localeCompare. If a pattern is provided, that part of the line will be used.
  sortn                               Sort the lines numerically (tries to be smart about scanning number)
  reverse                             Obvious
  line                                Prepend each line with the line number

  docprepend (docprefix)
  docappend (docsuffix)               Prepend, append, or surround the document (add header/footer)
  docsurround
  join  join/separator                Join lines with a space (or optional separator)

Example separators
------------------
  s/foo/bar
  s/foo/bar/
  s|foo|bar
  s{foo}bar

Line Number rules
-----------------
Using the special delimiter ':' you can apply most rules on line numbers instead of line content.
This bypasses any regular expression substitution (in case of 'sub' commands).

For example
  s:1:replace                      Replaces line 1 with the word "replace"
  p:1                              Only print line 1

Not all rules support this feature, but typically any rule that _could_ support it, _does_

Line numbers can be expressed as a single number, a range, an open range, a modulo operation, and a comma-separated list of rules
  p:1                              Only matches the line number (only matches line 1)
  p:%2                             Matches lines that are modulo-N (even lines)
  p:%2-1                           Matches lines that are modulo-N minus Y (odd lines)
  p:1,3,5                          Matches the listed line numbers (and only these)
  p:1-5                            Matches the range of number, inclusive (1,2,3,4,5)
  p:9-                             Matches the line number and all subsequent lines (lines 9 and onward)
  p:-9                             Matches lines up to and including the line number (lines 1-9)
  p:1-5,10-15,20,30+               Ranges and single lines can be mixed and matched

`)
}

function resetState() {
  return {
    // line-commands `on`, `after`, and `off` all share this value; toggles printing on/off
    printOn: null,
    lineNumber: 0,
  }
}

function ansi(code, input) {
  return `\x1b[${code}m${input}\x1b[0m`
}

function red(input, enabled) {
  return enabled ? ansi('1;31', input) : input
}

function green(input, enabled) {
  return enabled ? ansi('1;32', input) : input
}

function yellow(input, enabled) {
  return enabled ? ansi('38;5;227', input) : input
}

function magenta(input, enabled) {
  return enabled ? ansi('1;35', input) : input
}

function escapeShell(arg) {
  if (arg.match(/[;\\]/)) {
    return '"' + arg.replaceAll('\\', '\\\\').replaceAll('"', '\\"') + '"'
  }

  return arg
}

function writeLinesToFile(lines, file) {
  if (!file) {
    return
  }

  const output = lines.join('\n')
  fs.writeFileSync(file, output)
}

function diff(oldLines, newLines) {
  const result = []
  let oldIndex = 0
  let newIndex = 0

  while (oldIndex < oldLines.length || newIndex < newLines.length) {
    if (oldIndex >= oldLines.length) {
      // All remaining lines in newLines are additions
      result.push({type: 'added', lines: newLines.slice(newIndex)})
      newIndex = newLines.length
      break
    }

    if (newIndex >= newLines.length) {
      // All remaining lines in oldLines are removals
      result.push({type: 'removed', lines: oldLines.slice(oldIndex)})
      oldIndex = oldLines.length
      break
    }

    if (oldLines[oldIndex] === newLines[newIndex]) {
      // Lines are the same
      let sameCount = 0
      while (
        oldIndex + sameCount < oldLines.length &&
        newIndex + sameCount < newLines.length &&
        oldLines[oldIndex + sameCount] === newLines[newIndex + sameCount]
      ) {
        sameCount++
      }
      result.push({
        type: 'same',
        lines: oldLines.slice(oldIndex, oldIndex + sameCount),
      })
      oldIndex += sameCount
      newIndex += sameCount
    } else {
      // remove lines from old until same line
      let lhRemoveCount = 0
      let lhAddCount = 0
      while (
        oldIndex + lhRemoveCount < oldLines.length &&
        newLines.indexOf(oldLines[oldIndex + lhRemoveCount], newIndex) === -1
      ) {
        lhRemoveCount++
      }
      if (oldIndex + lhRemoveCount < oldLines.length) {
        lhAddCount =
          newLines.indexOf(oldLines[oldIndex + lhRemoveCount], newIndex) -
          newIndex
      } else {
        lhAddCount = newLines.length - newIndex
      }

      let rhRemoveCount = 0
      let rhAddCount = 0
      while (
        newIndex + rhAddCount < newLines.length &&
        oldLines.indexOf(newLines[newIndex + rhAddCount], oldIndex) === -1
      ) {
        rhAddCount++
      }
      if (newIndex + rhAddCount < newLines.length) {
        rhRemoveCount =
          oldLines.indexOf(newLines[newIndex + rhAddCount], oldIndex) - oldIndex
      } else {
        rhRemoveCount = oldLines.length - newIndex
      }

      if (lhRemoveCount + lhAddCount < rhAddCount + rhRemoveCount) {
        result.push({
          type: 'removed',
          lines: oldLines.slice(oldIndex, oldIndex + lhRemoveCount),
        })
        oldIndex += lhRemoveCount
        result.push({
          type: 'added',
          lines: newLines.slice(newIndex, newIndex + lhAddCount),
        })
        newIndex += lhAddCount
      } else {
        result.push({
          type: 'removed',
          lines: oldLines.slice(oldIndex, oldIndex + rhRemoveCount),
        })
        oldIndex += rhRemoveCount
        result.push({
          type: 'added',
          lines: newLines.slice(newIndex, newIndex + rhAddCount),
        })
        newIndex += rhAddCount
      }
    }
  }

  return result
}

if (!Array.prototype.toSorted) {
  Array.prototype.toSorted = function (compareFn) {
    return [...this].sort(compareFn)
  }
}

if (!Array.prototype.toReversed) {
  Array.prototype.toReversed = function () {
    return [...this].reverse()
  }
}

try {
  // remove 'node' and 'ssed' from argv
  main(process.argv.slice(2))
} catch (e) {
  process.stderr.write(`ssed: ${e.message}\n`)
}
