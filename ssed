#!/usr/bin/env node
const fs = require('fs')
const EventEmitter = require('events')
const {exec, execSync} = require('child_process')

process.stdout.on('error', function (err) {
  if (err.code === 'EPIPE') {
    exec('stty echo', () => {
      process.exit(0)
    })
  }
})

function requireArg(name, value) {
  if (value == null) {
    throw Error(`Missing argument: ${name}`)
  }
}

class LineRule {
  delim = ''
  pattern = ''
  replace
  args

  constructor(delim, pattern, replace, args) {
    this.delim = delim
    this.pattern = pattern
    this.replace = replace
    this.args = args
  }

  /**
   * Run before any lines are processed
   */
  before(state) {}
  /**
   * Run before every line
   */
  beforeEach(line, state) {}
  /**
   * Runs on every line, even if previous rules returned null/undefined
   */
  run(line, lineNo, _state) {
    if (line != null) {
      return this.line(line, lineNo)
    }
  }
  /**
   * Should only run on lines that have text, even if the text is ''
   */
  line(line, _lineNo) {}
  /**
   * Run after every line (or lines, if a rule returns multiple lines)
   */
  afterEach(line, state) {}
  /**
   * Run after all lines have processed.
   */
  after(state) {}

  explain() {
    return ''
  }
}

/**
 * Performs a single substitution on every line that matches. Use gsub to replace
 * multiple substitutions perline.
 *
 * When matching line numbers, the entire line is replaced with the matching text.
 *
 * Usage:
 *     ssed sub/{pattern}/{replace}
 *     ssed sub:{line-number}:replace-lines
 *
 * Aliases:
 *     ssed s/{pattern}/{replace}
 *
 * @example using regex
 *     this is text | sub/this/that => that is text
 *
 * @example Using line numbers
 *     this
 *     is
 *     text | sub:1:that => that
 *                          is
 *                          text
 */
class SubstitutionRule extends LineRule {
  constructor(delim, pattern, replace, args) {
    replace ??= ''
    requireArg('pattern', pattern)

    super(delim, pattern, replace, args)

    if (delim === ':') {
      const lineRangeTest = toLineRangeTest(pattern)
      this.line = (line, lineNo) => {
        if (lineRangeTest(line, lineNo)) {
          return replace
        }
        return line
      }
    } else {
      const regex = new RegExp(pattern)
      this.line = line => line.replace(regex, replace)
    }
  }

  explain() {
    return `Replace ${explainPattern(
      this.delim,
      this.pattern,
      'pattern',
    )} with '${this.replace}'`
  }
}

/**
 * Replaces every match with the substitution.
 *
 * Does not support line numbers.
 *
 * Usage:
 *     ssed gsub/{pattern}
 *
 * Aliases:
 *     ssed g/{pattern}
 *
 * @example Using regex
 *     this is text | gsub/t/T => This is TexT
 *     this is text | g|t|T => This is Text
 */
class GlobalSubstitutionRule extends LineRule {
  constructor(delim, pattern, replace) {
    if (delim === ':') {
      throw `'gsub' does not support line numbers (use 'sub')`
    }

    replace ??= ''
    requireArg('pattern', pattern)
    super(delim, pattern, replace ?? '', [])

    const regex = new RegExp(pattern, 'g')
    this.line = line => line.replace(regex, replace)
  }

  explain() {
    return `Replace all matches of ${explainPattern(
      this.delim,
      this.pattern,
      'pattern',
    )} with '${this.replace}'`
  }
}

/**
 * Only print the matching part of the line, or print the entire line if 'pattern'
 * doesn't match. (hint: Use `takeprint / tp` to only print matching lines)
 *
 * Does not support line numbers.
 *
 * Usage:
 *     ssed take/{pattern}
 *
 * Aliases:
 *     ssed t/{pattern}
 *
 * @example Using regex
 *     this is text | take/t\w+ => this
 *     this is text | t/t\w+ => this
 *     how now      | take/t\w+ => how now
 */
class TakeRule extends LineRule {
  constructor(delim, pattern) {
    if (delim === ':') {
      throw `'take' does not support line numbers`
    }

    super(delim, pattern, '', [])

    const regex = new RegExp(pattern)
    this.line = line => {
      const match = line.match(regex)
      return match ? match[0] : line
    }
  }

  explain() {
    return `If the line matches ${explainPattern(
      this.delim,
      this.pattern,
      'pattern',
    )}, only print the matching part of the line.`
  }
}

/**
 * Removes the matching part of the line, or print the entire line if 'pattern'
 * doesn't match.
 *
 * Usage:
 *     ssed rm/{pattern}
 *
 * Aliases:
 *     ssed r/{pattern}
 *
 * @example Using regex
 *     this is text | rm/^\w+ is/ => text
 */
class RemoveRule extends LineRule {
  constructor(delim, pattern) {
    if (delim === ':') {
      throw `'rm' does not support line numbers`
    }

    super(delim, pattern, '', [])

    const regex = new RegExp(pattern)
    this.line = line => line.replace(regex, '')
  }

  explain() {
    return `Remove ${explainPattern(
      this.delim,
      this.pattern,
      'pattern',
    )} from every line`
  }
}

/**
 * Only print lines that match 'pattern'.
 *
 * When matching line numbers, only the matching lines are printed. This works
 * identically to the 'take' command.
 *
 * Usage:
 *     ssed print/{pattern}
 *     ssed print:{line-number}
 *
 * Aliases:
 *     ssed p/{pattern}
 *
 * @example Using regex
 *     this
 *     is
 *     text | p/^t => this
 *                    text
 *
 * @example Using line numbers
 *     this
 *     is
 *     text | print:2-3 => is
 *                         text
 */
class PrintRule extends LineRule {
  constructor(delim, pattern) {
    pattern ??= ''
    super(delim, pattern, '', [])

    if (delim === ':') {
      this.check = toLineRangeTest(pattern)
    } else {
      const regex = new RegExp(pattern)
      this.check = line => line.match(regex)
    }
  }

  line(line, lineNo) {
    return this.check(line, lineNo) ? line : undefined
  }

  explain() {
    return `Print ${explainPattern(this.delim, this.pattern, 'matching-lines')}`
  }
}

/**
 * Removes lines that match the pattern. Inverse of "print".
 *
 * Usage:
 *    ssed kill/{pattern}
 *    ssed kill:{line-number}
 *
 * Aliases:
 *    ssed k/{pattern}
 *    ssed !p/{pattern}
 *    ssed !print/{pattern}
 *
 * When matching line numbers, the matching lines are removed.
 *
 * @example Using regex
 *     this
 *     is
 *     some
 *     text | k/is => some
 *                    text
 *
 * @example Using line numbers
 *     this
 *     is
 *     text | kill:1 => is
 *                      text
 */
class KillRule extends LineRule {
  constructor(delim, pattern, replace, args) {
    super(delim, pattern, replace, args)

    if (delim === ':') {
      this.check = toLineRangeTest(pattern)
    } else {
      const regex = new RegExp(pattern)
      this.check = line => line.match(regex)
    }
  }

  line(line, lineNo) {
    return this.check(line, lineNo) ? undefined : line
  }

  explain() {
    return `Remove ${explainPattern(
      this.delim,
      this.pattern,
      'matching-lines',
    )}`
  }
}

/**
 * Only prints unique lines. Default behaviour matches the entire line, but you can
 * specify a regular expression to only match part of the line. If the line doesn't
 * match, it isn't printed.
 *
 * Does not support line-numbers.
 *
 * Usage:
 *    ssed unique
 *    ssed unique/{pattern}
 *
 * Aliases:
 *    ssed uniq
 *
 * @example
 *     alice
 *     alice
 *     bob
 *     bob | uniq => alice
 *                   bob
 *
 * @example Using regex
 *     who is alice?
 *     what is alice?
 *     I don't know.
 *     do you know bob?
 *     does anyone know bob? | uniq/\w+\? => who is alice?
 *                                           do you know bob?
 */
class UniqueRule extends LineRule {
  constructor(delim, pattern, replace, args) {
    super(delim, pattern, replace, args)

    if (delim === ':') {
      throw Error(`'uniq' does not support line numbers`)
    }

    if (pattern) {
      const regex = new RegExp(pattern)
      this.part = line => {
        const match = line.match(regex)
        return match ? match[0] : null
      }
    } else {
      this.part = line => line
    }

    const uniqueLines = new Set()
    this.line = line => {
      const match = this.part(line)
      if (match == null) {
        return null
      }

      if (!uniqueLines.has(match)) {
        uniqueLines.add(match)
        return line
      }
    }
  }

  explain() {
    if (this.pattern) {
      return `Only print lines that match ${explainPattern(
        this.delim,
        this.pattern,
        'pattern',
      )}. Uniqueness is determined by the matching part of the line. The entire line is printed.`
    }
    return 'Only print unique lines'
  }
}

/**
 * Trims whitespace from the line. Defaults to trimming whitespace on both sides,
 * but 'left' or 'right' can be specified to only trim on one side.
 *
 * Usage:
 *    ssed trim
 *    ssed trim:left
 *    ssed trim:right
 *
 * @example '|' indicates start and end of line
 *     |     line 1|
 *     |line 2     |
 *     |   line 3  | ssed trim => |line 1|
 *                                |line 2|
 *                                |line 3|
 *
 * @example
 *     |     line 1|
 *     |line 2     |
 *     |   line 3  | ssed trim:right => |     line 1|
 *                                      |line 2|
 *                                      |   line 3|
 */
class TrimRule extends LineRule {
  constructor(delim, pattern, replace, args) {
    super(delim, pattern, replace, args)
    if (delim === ':') {
      throw `'trim' does not support line numbers`
    }

    // Set the appropriate trim function based on the pattern
    switch (pattern) {
      case 'left':
        this.trim = line => line.replace(/^\s+/, '')
        break
      case 'right':
        this.trim = line => line.replace(/\s+$/, '')
        break
      case 'both':
      default:
        this.trim = line => line.trim()
        break
    }

    this.line = line => this.trim(line)
  }

  explain() {
    switch (this.pattern) {
      case 'left':
        return 'Trim whitespace from the left side of the line'
      case 'right':
        return 'Trim whitespace from the right side of the line'
      default:
        return 'Trim whitespace from both sides of the line'
    }
  }
}

/**
 * Surround each line with text.
 *
 * Usage:
 *    ssed surround/{prepend}/{append}
 *
 * @example
 *     1
 *     2
 *     3
 *     4 | 'surround:->:<-' => ->1<-
 *                             ->2<-
 *                             ->3<-
 *                             ->4<-
 */
class SurroundRule extends LineRule {
  constructor(delim, prepend, append, args) {
    super(delim, '', '', args) // pattern and replace are not used in this rule
    this.prepend = prepend
    this.append = append
  }

  line(line) {
    return this.prepend + line + this.append
  }

  explain() {
    return `Surround each line with '${this.prepend}' and '${this.append}'`
  }
}

/**
 * Prepends (prefix) each line with text.
 *
 * Usage:
 *    ssed prepend/{text}
 *
 * Aliases:
 *    ssed prefix/{text}
 *
 * @example
 *     1
 *     2
 *     3
 *     4 | prepend:'line ' => line 1
 *                            line 2
 *                            line 3
 *                            line 4
 */
class PrependRule extends SurroundRule {
  constructor(delim, prependText, args) {
    super(delim, prependText, '', args)
  }

  explain() {
    return `Prepend each line with '${this.prepend}'`
  }
}

/**
 * Append (suffix) each line with text.
 *
 * Usage:
 *    ssed append/{text}
 *
 * Aliases:
 *    ssed suffix/{text}
 *
 * @example
 *     1
 *     2
 *     3
 *     4 | append:' foo' => 1 foo
 *                          2 foo
 *                          3 foo
 *                          4 foo
 */
class AppendRule extends SurroundRule {
  constructor(delim, appendText, args) {
    super(delim, '', appendText, args)
  }

  explain() {
    return `Append each line with '${this.append}'`
  }
}

/**
 * Insert text after each matching line.
 *
 * Usage:
 *    ssed insert/{pattern}/{text}
 *
 * @example
 *     1
 *     2
 *     3
 *     4 | 'insert:%2:!!!' => ->1<-
 *                            ->2<-
 *                            ->3<-
 *                            ->4<-
 */
class InsertRule extends LineRule {
  constructor(delim, pattern, text, args) {
    requireArg('pattern', pattern)
    requireArg('text', text)

    super(delim, pattern, text, args)
    if (delim === ':') {
      this.check = toLineRangeTest(pattern)
    } else {
      const regex = new RegExp(pattern)
      this.check = line => line.match(regex)
    }
  }

  line(line, lineNo) {
    if (this.check(line, lineNo)) {
      return [line, this.replace] // this.replace holds the text to be inserted
    }
    return line
  }

  explain() {
    return `After ${explainPattern(this.delim, this.pattern)} insert '${
      this.replace
    }'`
  }
}

/**
 * Commands to turn printing on and off based on a pattern or line number.
 *
 * on:     turn printing on at the matching line
 * after:  turn printing on after the matching line
 * off:    turn printing off at the matching line
 * toggle: printing starts on, toggles on matching lines
 *
 * Usage:
 *    ssed on/{pattern}
 *    ssed on:{line-number}
 *    ssed after/{pattern}
 *    ssed off/{pattern}
 *    ssed toggle/{pattern}
 *
 * @example
 *     a
 *     b
 *     c
 *     d
 *     e
 *     f
 *     g | on/b off/d after/f => b   # starts "off", is turned on by matching 'b'
 *                               c   # still "on", turned off by matching 'd'
 *                               g   # off until 'f', then turned on starting at next line
 */
class ControlPrintingRule extends LineRule {
  constructor(cmd, delim, pattern, args) {
    requireArg('pattern', pattern)

    super(delim, pattern, '', args)

    this.cmd = cmd
    if (delim === ':') {
      this.check = this.toLineRangeTest(pattern)
    } else {
      const regex = new RegExp(pattern)
      this.check = line => !!line.match(regex)
    }
  }

  beforeEach(line, state) {
    state.suppressedLine = null

    if (state.printOn == null) {
      if (this.cmd === 'on') {
        state.printOn = false
      } else if (this.cmd === 'off' || this.cmd === 'toggle') {
        state.printOn = true
      }
    }
  }

  run(line, lineNo, state) {
    if (
      this.cmd === 'on' &&
      state.suppressedLine != null &&
      this.check(state.suppressedLine, lineNo)
    ) {
      state.printOn = true
      line = state.suppressedLine
    } else if (
      this.cmd === 'on' &&
      line != null &&
      (state.printOn || this.check(line, lineNo))
    ) {
      state.printOn = true
    } else if (this.cmd === 'off' && state.printOn && this.check(line, lineNo)) {
      state.printOn = false
    } else if (this.cmd === 'toggle' && this.check(line, lineNo)) {
      state.printOn = !state.printOn
    }

    if (state.printOn) {
      state.suppressedLine = null
      return line
    } else {
      state.suppressedLine ??= line
    }

    if (
      this.cmd === 'after' &&
      state.suppressedLine != null &&
      !state.printOn &&
      this.check(state.suppressedLine, lineNo)
    ) {
      state.printOn = true
    } else if (this.cmd === 'after' && this.check(line, lineNo)) {
      state.printOn = true
    }
  }

  explain() {
    const matchingLines = explainPattern(
      this.delim,
      this.pattern,
      'matching-lines',
    )

    if (this.cmd === 'on') {
      return `Printing starts off, and is turned on at ${matchingLines}`
    }

    if (this.cmd === 'off') {
      return `Printing starts on, and is turned off at ${matchingLines}`
    }

    if (this.cmd === 'toggle') {
      return `Printing starts on, and is toggled at ${matchingLines}`
    }

    // cmd === 'after'
    return `Printing starts off, and is turned on after ${matchingLines}`
  }
}

/**
 * Replaces the pattern with the nth group of the match. If no pattern is given,
 * the line is separated by whitespace and the nth column is printed.
 *
 * Does not support line-numbers.
 *
 * Usage:
 *    # for every line that matches pattern, replace the Nth regex group
 *    ssed 1/{pattern(group1)}
 *    ssed 2/{pattern(group1)(group2)}
 *    ssed …/{pattern(…)}
 *
 *    # print the first "column" (columns are separated by whitespace, quotes are
 *    # ignored)
 *    ssed 1
 *
 * @example
 *     text | 1/\w(\w+)$ => ext
 *     this is text | 2/(\w+) (\w+) (\w+) => is
 */
class GroupMatchRule extends LineRule {
  constructor(index, delim, pattern) {
    super(delim, pattern, '', [])
    this.index = index

    if (delim === ':') {
      throw `'${index}' does not support line numbers`
    }

    if (!pattern) {
      this.line = line => {
        const match = line.split(/\s+/, index)
        return match.length >= index - 1 ? match[index - 1] : line
      }
    } else {
      const regex = new RegExp(pattern)
      this.line = line => {
        const match = line.match(regex)
        return match && match[index] ? match[index] : line
      }
    }
  }

  explain() {
    if (!this.pattern) {
      return `Print column #${this.index}, columns are separated by whitespace`
    }

    return `Replace ${explainPattern(
      this.delim,
      this.pattern,
      'pattern',
    )} with group #${this.index}`
  }
}

/**
 * A straightforward 'awk' feature: separate line on whitespace and print certain columns.
 *
 * Usage:
 *    # Use default separator (\s+) and print columns 1,3,2
 *    ssed cols//1,3,2
 *
 *    # Split lines by ':' and print columns 1 and 5
 *    # (columns will be joined with a space)
 *    ssed cols/:/1,5
 *
 *    # Same, but join columns using ':'
 *    ssed cols/:/1,5/:
 *
 * @example
 *     this    is    text | cols//2,1,3 => is this text
 *     1:bb:3:4:Z | cols/:/1,3,2 => 1 3 bb
 */
class ColumnsRule extends LineRule {
  constructor(delim, pattern, columns, args) {
    pattern ??= ''
    super(delim, pattern, '', [])

    requireArg('columns', columns)

    if (delim === ':') {
      throw new Error(`'cols' does not support line numbers`)
    }

    this.columns = columns.split(',').map(Number)
    const regex = pattern === '' ? /\s+/ : new RegExp(pattern)
    this.joiner = args[0] ?? ' '

    this.line = line => {
      const parts = line.split(regex)
      return this.columns.map(index => parts[index - 1] ?? '').join(this.joiner)
    }
  }

  explain() {
    let explanation = ''
    if (this.pattern) {
      explanation = `Split each line into columns using ${explainPattern(
        this.delim,
        this.pattern,
        'pattern',
      )}`
    } else {
      explanation = 'Split each line into columns by whitespace'
    }

    explanation += ` and print columns ${this.columns.join(', ')}`

    if (this.joiner) {
      explanation += ` joined by '${this.joiner}'`
    } else {
      explanation += ` joined by ' '`
    }

    return explanation
  }
}

class CombineRule extends LineRule {
  constructor(rule1, rule2) {
    super('', '', '', []) // Delim, pattern, replace, and args are not directly used in CombineRule
    this.rule1 = rule1
    this.rule2 = rule2
  }

  before(state) {
    this.rule1.before(state)
    this.rule2.before(state)
  }

  beforeEach(line, state) {
    this.rule1.beforeEach(line, state)
    this.rule2.beforeEach(line, state)
  }

  run(line, lineNo, state) {
    const result = this.rule1.run(line, lineNo, state)
    return this.rule2.run(result, lineNo, state)
  }

  afterEach(line, state) {
    this.rule1.afterEach(line, state)
    this.rule2.afterEach(line, state)
  }

  after(state) {
    this.rule1.after(state)
    this.rule2.after(state)
  }

  explain() {
    return `${this.rule1.explain()}\n${this.rule2.explain()}`
  }
}

function toLineRule([cmd, pattern, replace, rest, delim]) {
  let rule
  switch (cmd) {
    case 'sub':
    case 's':
      rule = new SubstitutionRule(delim, pattern, replace)
      break
    case 'gsub':
    case 'g':
      rule = new GlobalSubstitutionRule(delim, pattern, replace)
      break
    case 'take':
    case 't':
      rule = new TakeRule(delim, pattern)
      break
    case 'rm':
    case 'r':
      rule = new RemoveRule(delim, pattern, replace)
      break
    case 'print':
    case 'p':
      rule = new PrintRule(delim, pattern, replace)
      break
    case 'takeprint':
    case 'pt':
    case 'tp': {
      const take = new TakeRule(delim, pattern)
      const print = new PrintRule(delim, pattern)
      rule = new CombineRule(take, print)
      break
    }
    case 'rmprint':
    case 'pr':
    case 'rp': {
      const remove = removeRule(delim, pattern)
      const print = printRule(delim, pattern)
      rule = new CombineRule(remove, print)
      break
    }
    case 'kill':
    case 'k':
    case '!p':
    case '!print':
      rule = new KillRule(delim, pattern)
      break
    case 'uniq':
    case 'unique':
      rule = new UniqueRule(delim, pattern)
      break
    case 'trim':
      rule = new TrimRule(delim, pattern)
      break
    case 'prepend':
    case 'prefix':
      rule = new PrependRule(pattern)
      break
    case 'append':
    case 'suffix':
      rule = new AppendRule(pattern)
      break
    case 'surround':
      rule = new SurroundRule(pattern, replace)
      break
    case 'insert':
      rule = new InsertRule(delim, pattern, replace)
      break
    case 'on':
    case 'off':
    case 'after':
    case 'toggle':
      rule = new ControlPrintingRule(cmd, delim, pattern)
      break
    case 'cols':
      rule = new ColumnsRule(delim, pattern, replace, rest[0])
      break
    default:
      if (cmd.match(/^\d+$/)) {
        const index = parseInt(cmd)
        rule = new GroupMatchRule(index, delim, pattern)
      }
      break
  }

  return rule
}

function documentSortRule(pattern, replace, ascending) {
  const regex = pattern && new RegExp(pattern)
  return documentLines => {
    return documentLines.toSorted(([a], [b]) => {
      if (regex) {
        let aMatch = a.match(regex)
        let bMatch = b.match(regex)
        if (aMatch && bMatch) {
          if (replace != null) {
            aMatch = a.replace(regex, replace)
            bMatch = b.replace(regex, replace)
          } else {
            aMatch = aMatch[0]
            bMatch = bMatch[0]
          }

          return aMatch.localeCompare(bMatch) * (ascending ? 1 : -1)
        } else {
          return 0
        }
      }

      return a.localeCompare(b) * (ascending ? 1 : -1)
    })
  }
}

function documentSortNumericRule(pattern, replace, ascending) {
  const regex = pattern && new RegExp(pattern)
  return documentLines => {
    return documentLines
      .map(([line]) => line)
      .toSorted((a, b) => {
        if (regex) {
          let aMatch = a.match(regex)
          let bMatch = b.match(regex)
          if (aMatch && bMatch) {
            if (replace != null) {
              a = a.replace(regex, replace)
              b = b.replace(regex, replace)
            } else {
              a = aMatch[0]
              b = bMatch[0]
            }
          } else {
            return 0
          }
        }

        const numberA = a.replace(/^.*?(-?\b\d+(\.\d*)?).*$/, '$1')
        const numberB = b.replace(/^.*?(-?\b\d+(\.\d*)?).*$/, '$1')

        return (Number(numberA) - Number(numberB)) * (ascending ? 1 : -1)
      })
  }
}

function documentReverseRule() {
  return documentLines => documentLines.toReversed()
}

function documentLineNumbersRule(pattern, replace) {
  return documentLines => {
    const max = documentLines.length.toString().length
    return documentLines.map(([line, lineNo]) => {
      let lineNoStr = lineNo.toString()
      let pad
      if (replace) {
        pad = '0'.repeat(Math.max(Number(replace), max) - lineNoStr.length)
      } else {
        pad = ' '.repeat(max - lineNoStr.length)
      }
      const joiner = pattern ?? ':'
      return pad + lineNoStr + joiner + line
    })
  }
}

/**
 * Similar to the line substitution rule, but the substituted text is "spread"
 * across all the lines that match.
 */
function documentSubstituteLinesRule(pattern, replace, delim) {
  requireArg('pattern', pattern)

  const replaceLines = replace.split('\n')
  let index = 0
  let test

  if (delim === ':') {
    check = toLineRangeTest(pattern)
  } else {
    const regex = new RegExp(pattern)
    check = line => line.match(regex)
  }

  return documentLines => {
    const matchedLineNumbers = []
    // find all the lines that match, put into matchedLineNumbers
    // if (matchedLineNumbers >= replaceLines) {
    //   remove extra matched lines
    // } else (matchedLineNumbers < replaceLines) {
    //   add matched lines 1:1 with replaceLines until we
    //   get to the last matched line, then insert all
    //   remaining lines
    // }
    documentLines.forEach(([line, lineNo]) => {
      if (check(line, lineNo)) {
        matchedLineNumbers.push(lineNo)
      }
    })

    return documentLines.flatMap(([line, lineNo]) => {
      if (matchedLineNumbers.length && matchedLineNumbers[0] === lineNo) {
        matchedLineNumbers.shift()
        if (matchedLineNumbers.length === 0) {
          return replaceLines
        } else {
          const nextLine = replaceLines.shift()
          if (nextLine == null) {
            return []
          } else {
            return [nextLine]
          }
        }
      }

      return [line]
    })
  }
}

/**
 * Similar to the line substitution rule, but the substituted text is "spread"
 * across all the lines that match.
 */
function documentExecRule() {
  return (lines, _, options) => {
    const input = lines.map(([line]) => line).join('\n')

    if (options.dryRun) {
      return input.split('\n')
    }

    if (input) {
      return execSync(input).toString('utf-8').split('\n')
    }

    return []
  }
}

function documentSurroundRule(prependText, appendText) {
  const prependLines = prependText == '' ? [] : prependText.split('\n')
  const appendLines = appendText == '' ? [] : appendText.split('\n')
  const prependLength = prependLines.length

  return documentLines => {
    return prependLines
      .map((line, index) => line)
      .concat(
        documentLines.map(([line, lineNo]) => {
          return line
        }),
      )
      .concat(appendLines)
  }
}

function documentJoinLinesRule(joiner) {
  return documentLines =>
    documentLines.map(([line]) => line).join(joiner || ' ')
}

function documentLinesRule(lineRules) {
  return (documentLines, _, options) => {
    const state = resetState()

    for (const lineRule of lineRules) {
      lineRule.before?.(state)
    }

    const inputLines = [...documentLines].map(([line]) => line)
    const isLastLineBlank = inputLines.at(-1) === ''
    if (isLastLineBlank) {
      inputLines.pop()
    }

    const retLines = []
    processLines(state, true, lineRules, options, retLines, inputLines)

    for (const lineRule of lineRules) {
      lineRule.after?.(state)
    }

    if (isLastLineBlank) {
      retLines.push('')
    }

    return retLines
  }
}

function documentCountRule() {
  return documentLines => [documentLines.length.toString()]
}

function toDocumentRule([cmd, pattern, replace, rest, delim]) {
  switch (cmd) {
    case 'count':
      return documentCountRule()
    case '!sort':
    case 'sort':
      return documentSortRule(pattern, replace, !cmd.startsWith('!'))
    case '!sortn':
    case 'sortn':
      return documentSortNumericRule(pattern, replace, !cmd.startsWith('!'))
    case 'reverse':
      return documentReverseRule()
    case 'begin':
    case 'border':
      return documentSurroundRule(pattern ?? '', replace ?? '')
    case 'after':
      return documentSurroundRule('', pattern)
    case 'line':
    case 'lines':
      return documentLineNumbersRule(pattern, replace)
    case 'join':
      return documentJoinLinesRule(pattern)
    case 'sl':
    case 'sublines':
      return documentSubstituteLinesRule(pattern, replace, delim)
    case 'exec':
      return documentExecRule()
    case 'help':
      help()
      process.exit(0)
    case 'docsurround':
      console.error('`' + cmd + '` is deprecated, use `border` instead')
      process.exit(1)
    case 'docprepend':
    case 'docprefix':
      console.error('`' + cmd + '` is deprecated, use `begin` instead')
      process.exit(1)
    case 'docappend':
    case 'docsuffix':
      console.error('`' + cmd + '` is deprecated, use `after` instead')
      process.exit(1)
    default:
      console.error('Unknown command: ' + cmd)
      process.exit(1)
  }
}

function escapeRegex(pattern) {
  return pattern.replaceAll('/', '\\/')
}

function explainPattern(delim, pattern, text) {
  if (delim === ':') {
    return _toLineRangeTest(pattern, 'explain')
  }

  if (text === 'pattern') {
    return `/\\${escapeRegex(pattern)}/`
  } else if (text === 'matching-lines') {
    return `lines that match /\\${escapeRegex(pattern)}/`
  }

  return `/\\${escapeRegex(pattern)}/`
}

function toLineRangeTest(pattern) {
  return _toLineRangeTest(pattern, 'run')
}

function _toLineRangeTest(pattern, job) {
  if (!pattern.match(/^[\d*%,-]*$/)) {
    throw Error('Invalid line range pattern')
  }

  if (!pattern || pattern === '*') {
    if (job === 'explain') {
      return 'all lines'
    }

    return () => true
  }

  if (pattern.includes(',')) {
    const rules = pattern.split(',').map(rule => toLineRangeTest(rule, job))
    if (job === 'explain') {
      return `(${rules.join(' or ')})`
    }

    return (line, lineNo) => rules.some(fn => fn(line, lineNo))
  }

  if (pattern.startsWith('%')) {
    let modulus = pattern.slice(1)
    if (modulus.includes('-')) {
      const [mod, offset] = modulus.split('-', 2).map(Number)
      if (job === 'explain') {
        return `every ${mod}-th - ${offset} line`
      }

      return (_, lineNo) => (lineNo + offset) % mod === 0
    } else {
      if (job === 'explain') {
        return `every ${modulus}-th line`
      }

      return (_, lineNo) => lineNo % Number(modulus) === 0
    }
  }

  if (pattern.includes('+')) {
    throw Error('Invalid line range symbol `+`')
  }

  if (pattern.includes('-')) {
    const [start, stop] = pattern.split('-', 2).map((number, index) => {
      if (number === '' && index === 0) {
        return 1
      } else if (number === '' && index === 1) {
        return Infinity
      } else {
        return Number(number)
      }
    })

    if (job === 'explain') {
      return start === 0 && stop === Infinity
        ? 'all lines'
        : start === 0
        ? `lines up to ${stop}`
        : stop === Infinity
        ? `lines from ${start} to end`
        : `lines from ${start} to ${stop}`
    }

    return (_, lineNo) => lineNo >= start && lineNo <= stop
  }

  if (job === 'explain') {
    return `line ${Number(pattern)}`
  }

  return (_, lineNo) => lineNo === Number(pattern)
}

function lineStream(inputStream, transform = undefined) {
  const stdin = new EventEmitter()
  let buffer = ''
  let closed = false

  function emit(line) {
    if (closed) {
      return
    }

    if (transform) {
      line = transform(line)
    }

    if (line !== undefined) {
      stdin.emit('line', line)
    }
  }

  inputStream.on('open', function () {
    stdin.emit('open')
  })
  inputStream.on('data', function (chunk) {
    buffer += chunk
    const lines = buffer.split('\n')
    buffer = lines.pop()
    lines.forEach(line => emit(line))
  })

  inputStream.on('end', () => {
    emit(buffer)
    let autoclose = true
    function keepOpen() {
      autoclose = false
    }
    function close() {
      stdin.emit('close')
    }
    stdin.emit('end', keepOpen, close)
    if (autoclose) {
      close()
    }
  })

  inputStream.resume()
  inputStream.setEncoding('utf-8')

  stdin.pause = inputStream.pause.bind(inputStream)
  stdin.close = () => {
    closed = true
    inputStream.pause()
  }
  stdin.pipe = transform => {
    return lineStream(stdin, transform)
  }

  return stdin
}

function parseOption(options, arg, args) {
  let option
  if (arg.startsWith('--')) {
    ;[option] = arg.slice(2).match(/^([\w-]+)/) ?? [option]
  } else if (arg.startsWith('-')) {
    ;[option] = arg.slice(1).match(/^(\w+)/) ?? [option]
    return option.split('').map(opt => parseOption(options, `--${opt}`, args))
  } else {
    return
  }

  switch (option) {
    case 'h':
    case 'help': {
      help()
      process.exit(0)
    }
    case 'no-color':
    case 'color': {
      return {
        color: option === 'color',
      }
    }
    case 'n':
    case 'no-dry-run':
    case 'dry-run': {
      return {
        dryRun: option === 'dry-run',
      }
    }
    case 'no-diff':
    case 'diff': {
      return {
        diff: option === 'diff',
      }
    }
    case 'no-interactive':
    case 'interactive': {
      return {
        interactive: option === 'interactive',
      }
    }
    case 'no-write':
    case 'write': {
      const [, writeToFile] = arg.split('=', 2)

      return {
        write: option === 'write',
        diff: option === 'write',
        writeToFile,
      }
    }
    case 'no-input':
      return {inputFromFile: false, input: process.stdin}
    case 'ls':
      return {inputFromFile: true, input: null}
    case 'input': {
      let file
      if (arg.match(/^--input=/)) {
        ;[, file] = arg.split('=', 2)
      } else {
        file = args.shift()
      }

      const files = file.split(',')
      const prevFiles = Array.isArray(options.input) ? options.input : []
      if (files.length > 1) {
        return {
          inputFromFile: true,
          input: [
            ...prevFiles,
            files.map(file => {
              if (fs.existsSync(file)) {
                return file
              } else {
                throw Error(`File does not exist: ${file}`)
              }
            }),
          ],
        }
      } else {
        if (fs.existsSync(file)) {
          return {
            inputFromFile: true,
            input: prevFiles.length ? [...prevFiles, file] : file,
          }
        } else {
          throw Error(`File does not exist: ${file}`)
        }
      }
      break
    }
    default:
      throw Error(`Invalid option: ${option}`)
  }
}

function processLines(
  state,
  hasDocumentRules,
  lineRules,
  options,
  lines,
  linesBuffer,
) {
  for (const line of linesBuffer) {
    state.lineNumber += 1

    for (const lineRule of lineRules) {
      lineRule.beforeEach?.(line, state)
    }

    let mappedLines = [line]
    for (const lineRule of lineRules) {
      if (mappedLines.length === 0) {
        mappedLines = [null]
      }

      mappedLines = mappedLines.flatMap(line => {
        const nextLines = lineRule.run(line, state.lineNumber, state)
        if (nextLines == null) {
          return []
        } else if (Array.isArray(nextLines)) {
          return nextLines
        } else {
          return [nextLines]
        }
      })
    }

    for (const lineRule of lineRules) {
      mappedLines.forEach(line => {
        lineRule.afterEach?.(line, state)
      })
    }

    if (mappedLines.length > 0) {
      if (!options.diff && !hasDocumentRules) {
        mappedLines.forEach(line => options.print(line))
      } else {
        lines.push(...mappedLines)
      }
    }
  }
}

function main(args, options = {}) {
  options = {
    ...options,
    input: process.stdin,
    inputFromFile: false,
    interactive: false,
    write: false,
    writeToFile: null,
    diff: false,
    diffHeader: '',
    diffContext: 3, // number of lines to print before and after diffs
    color: process.stdout.isTTY,
    print: (line, nl = true) => {
      process.stdout.write(line + (nl ? '\n' : ''))
    },
    error: (line, nl = true) => {
      process.stderr.write(line + (nl ? '\n' : ''))
    },
  }

  let lineRules = []
  const documentRules = []

  const argsCopy = [...args]
  const rules = []
  let arg
  while ((arg = argsCopy.shift()) != null) {
    const option = parseOption(options, arg, argsCopy)
    if (option !== undefined) {
      options = {...options, ...option}
    } else {
      rules.push(arg)
    }
  }

  // array / null input
  // array => list of files (ssed --input=file1,file2)
  // null => read files from stdin (ssed --input - )
  if (options.inputFromFile && typeof options.input !== 'string') {
    function next(file) {
      main([], {
        ...options,
        input: file,
      })
        .on('open', () => {
          if (!options.diff) {
            options.print(yellow(`ssed: ${file}`))
          }
        })
        .on('close', next)
    }

    if (options.input === null) {
      const stdin = lineStream(process.stdin)
      // treat stdin as list of files

      stdin.on('line', file => {
        next(file)
      })
    } else if (Array.isArray(options.input)) {
      options.input.forEach(next)
    }

    return
  }

  if (options.inputFromFile) {
    options.diffHeader = `diff ${options.input}
--- ${options.input}
+++ ssed ${args.map(escapeShell).join(' ')}`

    const file = options.input
    if (options.write && !options.writeToFile && file !== process.stdin) {
      options.writeToFile = file
    } else if (options.writeToFile) {
      options.writeToFile = options.writeToFile.replace('%', file)
    }

    options.input = fs.createReadStream(file)
  }

  for (const rule of rules) {
    const parsed = parseRuleArgs(rule)

    let lineRule, documentRule
    if ((lineRule = toLineRule(parsed))) {
      lineRules.push(lineRule)
    } else if ((documentRule = toDocumentRule(parsed))) {
      if (lineRules.length) {
        documentRules.push(documentLinesRule(lineRules))
        lineRules = []
      }

      documentRules.push(documentRule)
    } else {
      throw Error(`Invalid rule: ${rule}`)
    }
  }

  if (lineRules.length && documentRules.length) {
    documentRules.push(documentLinesRule(lineRules))
    lineRules = []
  }

  const inputStream = lineStream(options.input)
  const originalLines = []
  let lines = []

  // if (
  //   we only have line rules,
  //   no document rules,
  //   and we're not diffing the output
  // ), then: we perform a "stream edit".
  //
  // 1. create a state for the line rules
  // 2. don't store the output in lines
  // 3. output immediately
  const state = resetState()

  for (const lineRule of lineRules) {
    lineRule.before?.(state)
  }

  let linesBuffer = []
  return inputStream
    .on('line', line => {
      const original = line
      originalLines.push(original)

      linesBuffer.push(line)
      // special handling for blank lines – if the last line is blank we skip it
      if (line === '') {
        return
      }

      processLines(
        state,
        documentRules.length > 0,
        lineRules,
        options,
        lines,
        linesBuffer,
      )

      linesBuffer = []
    })
    .on('end', (keepOpen, close) => {
      if (linesBuffer.length === 1) {
        if (!options.diff && documentRules.length === 0) {
          options.print('')
        } else {
          state.lineNumber += 1
          lines.push('')
        }
      } else if (linesBuffer.length) {
        processLines(
          state,
          documentRules.length > 0,
          lineRules,
          options,
          lines,
          linesBuffer,
        )
      }

      for (const lineRule of lineRules) {
        lineRule.after?.(state)
      }

      const isLastLineBlank = lines.at(-1) === ''
      if (isLastLineBlank) {
        lines.pop()
      }

      for (const documentRule of documentRules) {
        const linesWithNumbers = lines.map((line, index) => [line, index + 1])
        lines = documentRule(linesWithNumbers, state, options)
        if (!lines?.length) {
          break
        }
      }

      const finalLines = lines ?? []
      if (isLastLineBlank) {
        finalLines.push('')
      }

      if (options.diff) {
        const linesDiff = diff(originalLines, finalLines)
        const hasDiff = !(
          linesDiff.length === 1 && linesDiff[0].type === 'same'
        )
        if (hasDiff) {
          options.print(yellow(options.diffHeader, options.color))

          let inputLineNumber = 1
          let outputLineNumber = 1
          let didPrintNumbers = false
          function printLineNumbers(inputLineNumber, outputLineNumber) {
            if (!didPrintNumbers) {
              options.print(
                magenta(
                  `@@ -${inputLineNumber} +${outputLineNumber} @@`,
                  options.color,
                ),
              )

              didPrintNumbers = true
            }
          }

          linesDiff.forEach((entry, index) => {
            if (!entry.lines.length) {
              return
            }

            if (entry.type === 'same') {
              if (index === 0) {
                didPrintNumbers = false

                const printLines = entry.lines.slice(
                  Math.max(entry.lines.length - 3, 0),
                )
                inputLineNumber += entry.lines.length - printLines.length
                outputLineNumber += entry.lines.length - printLines.length
                printLineNumbers(inputLineNumber, outputLineNumber)
                printLines.forEach(line => options.print(line))
                inputLineNumber += printLines.length
                outputLineNumber += printLines.length
              } else if (index === linesDiff.length - 1) {
                const printLines = entry.lines.slice(0, 4)
                printLineNumbers(inputLineNumber, outputLineNumber)
                inputLineNumber += entry.lines.length - printLines.length
                outputLineNumber += entry.lines.length - printLines.length
                printLines.forEach(line => options.print(line))
                inputLineNumber += printLines.length
                outputLineNumber += printLines.length
              } else if (entry.lines.length <= 5) {
                entry.lines.forEach(line => options.print(line))
                inputLineNumber += entry.lines.length
                outputLineNumber += entry.lines.length
              } else {
                didPrintNumbers = false

                const beforeLines = entry.lines.slice(0, 3)
                const afterLines = entry.lines.slice(
                  Math.max(entry.lines.length - 3, 0),
                )
                beforeLines.forEach(line => options.print(line))
                inputLineNumber += entry.lines.length - afterLines.length
                outputLineNumber += entry.lines.length - afterLines.length
                printLineNumbers(inputLineNumber, outputLineNumber)
                afterLines.forEach(line => options.print(line))
              }

              return
            }

            entry.lines.forEach(line => {
              printLineNumbers(inputLineNumber, outputLineNumber)

              if (entry.type === 'added') {
                outputLineNumber += 1
                options.print(green(`+${line}`, options.color))
              } else if (entry.type === 'removed') {
                inputLineNumber += 1
                options.print(red(`-${line}`, options.color))
              }
            })
          })

          if (options.write) {
            if (options.interactive) {
              if (!process.stdin.isTTY) {
                options.error(
                  red(
                    `Cannot run interactively – input is coming from stdin`,
                    options.color,
                  ),
                )
                process.exit(1)
              }

              options.print(
                yellow(
                  `Write changes to ${options.writeToFile}? [Yn] `,
                  options.color,
                ),
                false,
              )
              keepOpen()

              const stdin = lineStream(process.stdin)
              stdin.on('line', line => {
                if (line === '' || line === 'y' || line === 'yes') {
                  if (options.dryRun) {
                    options.error(
                      yellow(`Dry Run: ${options.writeToFile}`, options.color),
                    )
                  } else {
                    writeLinesToFile(finalLines, options.writeToFile)
                  }
                } else if (line === 'n') {
                  options.error(
                    yellow(`Skipping ${options.writeToFile}`, options.color),
                  )
                } else {
                  options.error(
                    red(`Unknown response '${line}'. Aborting`, options.color),
                  )
                  process.exit(1)
                }
                stdin.close()
                close()
              })
            } else {
              if (options.dryRun) {
                options.error(
                  yellow(`Dry Run: ${options.writeToFile}`, options.color),
                )
              } else {
                writeLinesToFile(finalLines, options.writeToFile)
              }
            }
          }
        }
      } else {
        for (const line of finalLines) {
          options.print(line)
        }
      }
    })
}

function delimiterTestFn(delim) {
  if (delim === '{' || delim === '}') {
    return char => /[\{\}]/.test(char)
  }

  if (delim === '[' || delim === ']') {
    return char => /[\[\]]/.test(char)
  }

  if (delim === '(' || delim === ')') {
    return char => /[\(\)]/.test(char)
  }

  if (delim === '<' || delim === '>') {
    return char => /[<>]/.test(char)
  }

  return char => char === delim
}

function split(str, delim) {
  const test = delimiterTestFn(delim)
  const args = []
  let buffer = ''
  let isEscaped = false
  for (const char of str) {
    if (isEscaped) {
      if (char !== delim) {
        buffer += '\\'
      }
      buffer += char
      isEscaped = false
      continue
    }

    if (char === '\\') {
      isEscaped = true
      continue
    }

    if (test(char)) {
      args.push(buffer)
      buffer = ''
    } else {
      buffer += char
    }
  }

  if (buffer.length) {
    args.push(buffer)
  }

  return args
}

function unescape(str) {
  return str.replace(/\\(.)/g, (_, char) => {
    if (char === 'n') {
      return '\n'
    }
    if (char === 't') {
      return '\t'
    }
    return `\\${char}`
  })
}

function parseRuleArgs(rule) {
  const command = rule.match(/^(!?\w+\b|\d+)(.)/)
  if (!command) {
    const [simpleCommand] = rule.match(/^!?(\w+\b|\d+)$/) ?? []
    if (!simpleCommand) {
      throw Error(`Invalid rule: ${rule}`)
    }
    return [simpleCommand, null, null, []]
  }

  const [cmd, delim] = [command[1], command[2]]
  const argsString = rule.slice(command[0].length)
  const splitArgs = split(argsString, delim)
  const [pattern, replace, ...rest] = splitArgs.map(unescape)

  return [cmd.toLowerCase(), pattern, replace, rest, delim]
}

function help() {
  process.stderr.write(`Usage:
  ssed [options] [rules]

About
-----
    ssed is an alternative to 'sed'. Not a drop-in replacement, but used for
    similar tasks. I wanted more familiar and modern Regex support, and have
    kept adding more functions as ssed became more and more my go-to text
    manipulation tool.

    Line rules transform on a line-by-line basis and, if only line rules are
    employed, support STDIN streaming.

    Document rules transform the entire document. STDIN is read to completion
    before document rules are executed.

    If the last line is blank, it is ignored.

Options
-------
  --diff                       Only show differences
  --no-diff                    Do not show differences

  --color                      Enable ANSI colors (true if stdout is a TTY)
  --no-color                   Disable ANSI colors

  --ls                         Read file names from standard input (\`ls | ssed --ls\`)

  --input=fromfile             Use 'fromfile' as input
  aka --input fromfile

  --input=fromfile1,fromfile2  Run against multiple files.
  aka --input fromfile1 --input fromfile2

  --write                      Write each changed file in place.
  --write=tofile               Provide a destination file name.
  --write=%.backup             '\%' is replaced with the input file.
  --no-write                   Do not write each changed file in place.

  --interactive                Ask before writing the file
  --no-interactive             Do not ask before writing the file

  --dry-run (-n)               Show which files would be affected.
  --no-dry-run                 Do not show which files would be affected.

Line Rules
----------
Line rules operate on every line. Commands 'on', 'after' and 'off' share the on/off state.

  s/search/replace (aka sub/…/…)   Replace the first instance of 'search' with 'replace'
  g/search/replace (aka gsub/…/…)  Replace every instance of 'search' with 'replace'
  t/pattern (aka take/…)           Only print the matching part of the line, or print the entire line if 'pattern' doesn't match
  r/pattern (aka rm/…)             Remove the matching part of the line, or print the entire line if 'pattern' doesn't match
  1/pattern                        Only print the first group of the match
  1                                Only print the first "column" (columns are separated by whitespace)
  cols/pattern/columns             Split the line by 'pattern' (default is /\\s+/) and print columns
                                   - columns can be separated by commas
                                   - columns are joined by ' '
  cols/pattern/columns/joiner      - columns are joiner by $joiner

  on/pattern                       Start printing on the line where 'pattern' is matched
  off/pattern                      Stop printing on the line where 'pattern' is matched
  after/pattern                    Start printing on the line *after* 'pattern' is matched
  toggle/pattern                   Turn printing off at the matching line, then off, then on...

  p/pattern (aka print/…)          Only print lines that match 'pattern'
  k/pattern (aka kill/…)           Do not print lines that match 'pattern'
  !p/pattern (aka !print/…)        Alias for k/kill because I can't remember one (k) and always remember the other (p)

  prepend/text (aka prefix/…)
  append/text (aka suffix/…)       Adds text to the beginning (prepend) or end (append) of the line
  surround/prefix/suffix

  uniq (aka unique)                Only print unique lines
  uniq/pattern                     Only print matching lines, and only unique matches (uniqueness is determined by the matching regex)

Document Rules
--------------
  sublines/pattern/replace            For every line that matches, insert one line from replace. Remaining lines will
       (aka sl/…)                     be inserted into the last matched line. Does not do regex replacement.

  sort  sort/pattern                  Sort the lines alphabettically using localeCompare. If a pattern is provided, that part of the line will be used.
  sortn                               Sort the lines numerically (tries to be smart about scanning number)
  reverse                             Obvious
  line                                Prepend each line with the line number

  docprepend (docprefix)
  docappend (docsuffix)               Prepend, append, or surround the document (add header/footer)
  docsurround
  join  join/separator                Join lines with a space (or optional separator)

Example separators
------------------
  s/foo/bar
  s/foo/bar/
  s|foo|bar
  s{foo}bar

Line Number rules
-----------------
Using the special delimiter ':' you can apply most rules on line numbers instead of line content.
This bypasses any regular expression substitution (in case of 'sub' commands).

For example
  s:1:replace                      Replaces line 1 with the word "replace"
  p:1                              Only print line 1

Not all rules support this feature, but typically any rule that _could_ support it, _does_

Line numbers can be expressed as a single number, a range, an open range, a modulo operation, and a comma-separated list of rules
  p:1                              Only matches the line number (only matches line 1)
  p:%2                             Matches lines that are modulo-N (even lines)
  p:%2-1                           Matches lines that are modulo-N minus Y (odd lines)
  p:1,3,5                          Matches the listed line numbers (and only these)
  p:1-5                            Matches the range of number, inclusive (1,2,3,4,5)
  p:9-                             Matches the line number and all subsequent lines (lines 9 and onward)
  p:-9                             Matches lines up to and including the line number (lines 1-9)
  p:1-5,10-15,20,30+               Ranges and single lines can be mixed and matched

`)
}

function resetState() {
  return {
    // line-commands `on`, `after`, and `off` all share this value; toggles printing on/off
    printOn: null,
    lineNumber: 0,
  }
}

function ansi(code, input) {
  return `\x1b[${code}m${input}\x1b[0m`
}

function red(input, enabled) {
  return enabled ? ansi('1;31', input) : input
}

function green(input, enabled) {
  return enabled ? ansi('1;32', input) : input
}

function yellow(input, enabled) {
  return enabled ? ansi('38;5;227', input) : input
}

function magenta(input, enabled) {
  return enabled ? ansi('1;35', input) : input
}

function escapeShell(arg) {
  if (arg.match(/[;\\]/)) {
    return '"' + arg.replaceAll('\\', '\\\\').replaceAll('"', '\\"') + '"'
  }

  return arg
}

function writeLinesToFile(lines, file) {
  if (!file) {
    return
  }

  const output = lines.join('\n')
  fs.writeFileSync(file, output)
}

function diff(oldLines, newLines) {
  const result = []
  let oldIndex = 0
  let newIndex = 0

  while (oldIndex < oldLines.length || newIndex < newLines.length) {
    if (oldIndex >= oldLines.length) {
      // All remaining lines in newLines are additions
      result.push({type: 'added', lines: newLines.slice(newIndex)})
      newIndex = newLines.length
      break
    }

    if (newIndex >= newLines.length) {
      // All remaining lines in oldLines are removals
      result.push({type: 'removed', lines: oldLines.slice(oldIndex)})
      oldIndex = oldLines.length
      break
    }

    if (oldLines[oldIndex] === newLines[newIndex]) {
      // Lines are the same
      let sameCount = 0
      while (
        oldIndex + sameCount < oldLines.length &&
        newIndex + sameCount < newLines.length &&
        oldLines[oldIndex + sameCount] === newLines[newIndex + sameCount]
      ) {
        sameCount++
      }
      result.push({
        type: 'same',
        lines: oldLines.slice(oldIndex, oldIndex + sameCount),
      })
      oldIndex += sameCount
      newIndex += sameCount
    } else {
      // remove lines from old until same line
      let lhRemoveCount = 0
      let lhAddCount = 0
      while (
        oldIndex + lhRemoveCount < oldLines.length &&
        newLines.indexOf(oldLines[oldIndex + lhRemoveCount], newIndex) === -1
      ) {
        lhRemoveCount++
      }
      if (oldIndex + lhRemoveCount < oldLines.length) {
        lhAddCount =
          newLines.indexOf(oldLines[oldIndex + lhRemoveCount], newIndex) -
          newIndex
      } else {
        lhAddCount = newLines.length - newIndex
      }

      let rhRemoveCount = 0
      let rhAddCount = 0
      while (
        newIndex + rhAddCount < newLines.length &&
        oldLines.indexOf(newLines[newIndex + rhAddCount], oldIndex) === -1
      ) {
        rhAddCount++
      }
      if (newIndex + rhAddCount < newLines.length) {
        rhRemoveCount =
          oldLines.indexOf(newLines[newIndex + rhAddCount], oldIndex) - oldIndex
      } else {
        rhRemoveCount = oldLines.length - newIndex
      }

      if (lhRemoveCount + lhAddCount < rhAddCount + rhRemoveCount) {
        result.push({
          type: 'removed',
          lines: oldLines.slice(oldIndex, oldIndex + lhRemoveCount),
        })
        oldIndex += lhRemoveCount
        result.push({
          type: 'added',
          lines: newLines.slice(newIndex, newIndex + lhAddCount),
        })
        newIndex += lhAddCount
      } else {
        result.push({
          type: 'removed',
          lines: oldLines.slice(oldIndex, oldIndex + rhRemoveCount),
        })
        oldIndex += rhRemoveCount
        result.push({
          type: 'added',
          lines: newLines.slice(newIndex, newIndex + rhAddCount),
        })
        newIndex += rhAddCount
      }
    }
  }

  return result
}

if (!Array.prototype.toSorted) {
  Array.prototype.toSorted = function (compareFn) {
    return [...this].sort(compareFn)
  }
}

try {
  // remove 'node' and 'ssed' from argv
  main(process.argv.slice(2))
} catch (e) {
  process.stderr.write(`ssed: ${e.message}\n`)
}
