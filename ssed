#!/usr/bin/env node
const fs = require('fs')
const inspect = require('util').inspect
const EventEmitter = require('events')

function toDelim(delim) {
  if (delim === '{' || delim === '}') {
    return /[\{\}]/
  }

  if (delim === '[' || delim === ']') {
    return /[\[\]]/
  }

  if (delim === '(' || delim === ')') {
    return /[\(\)]/
  }

  if (delim === '<' || delim === '>') {
    return /[<>]/
  }

  return delim
}

function unescape(str) {
  return str.replace(/\\(.)/g, (_, char) => {
    if (char === 'n') {
      return '\n'
    }
    if (char === 't') {
      return '\t'
    }
    return `\\${char}`
  })
}

function parseRuleArgs(rule) {
  const command = rule.match(/^(\w+\b|\d+|!p(?:rint)?)(.)/)
  if (!command) {
    const [simpleCommand] = rule.match(/^(\w+\b|\d+|!p(?:rint)?)$/) ?? []
    if (!simpleCommand) {
      throw Error(`Invalid: ${rule}`)
    }
    return [simpleCommand, '', '', []]
  }

  const [cmd, delim] = [command[1], command[2]]
  const [, ...args] = rule
    .slice(delim.length)
    .split(toDelim(delim))
    .map(unescape)
  const [pattern, replace] = args

  return [cmd.toLowerCase(), pattern ?? '', replace ?? '', args, delim]
}

function help() {
  process.stderr.write(`usage: ssed [options] [rules]

Options:
  --diff                       Only show differences
  --no-diff                    Do not show differences

  --color                      Enable ANSI colors (true if stdout is a TTY)
  --no-color                   Disable ANSI colors

  --input                      Take file names from standard input (\`ls | ssed --input\`)
  --input=fromfile             Use 'fromfile' as input
  --input=fromfile1,fromfile2  Run against multiple files.

  --write                      Write each changed file in place.
  --write=tofile               Provide a destination file name.
  --write=%.backup             '\%' is replaced with the input file.
  --no-write                   Do not write each changed file in place.

  --interactive                Ask before writing the file
  --no-interactive             Do not ask before writing the file

  --dry-run (-n)               Show which files would be affected.
  --no-dry-run                 Do not show which files would be affected.

Line Rules
----------
Line rules operate on every line. Commands 'on', 'after' and 'off' share the on/off state.

  s/search/replace (aka sub/…/…)   Replace the first instance of 'search' with 'replace'
  g/search/replace (aka gsub/…/…)  Replace every instance of 'search' with 'replace'
  t/pattern (aka take/…)           Only print the matching part of the line, or print the entire line if 'pattern' doesn't match
  1/pattern                        Only print the first group of the match
  r/pattern (aka rm/…)             Remove the matching part of the line, or print the entire line if 'pattern' doesn't match
  o/pattern (aka on/…)             Start printing on the line where 'pattern' is matched
  a/pattern (aka after/…)          Start printing on the line *after* 'pattern' is matched
  f/pattern (aka off/…)            Turn printing off on the line where 'pattern' is matched
  p/pattern (aka print/…)          Only print lines that match 'pattern'
  k/pattern (aka kill/…)           Do not print lines that match 'pattern'
  !p/pattern (aka !print/…)        Alias for k/kill because I can't remember one (k) and always remember the other (p)
  prepend/text  append/text  surround/prefix/suffix
                                   Adds text to the beginning or end of the line

  uniq (aka unique)                Only print unique lines
  uniq/pattern                     Only print matching lines, and only unique matches (uniqueness is determined by the matching regex)

Document Rules:
  sort  sort/pattern                  Sort the lines alphabettically using localeCompare. If a pattern is provided, that part of the line will be used.
  sortn                               Sort the lines numerically (tries to be smart about scanning number)
  reverse                             Obvious
  line                                Prepend each line with the line number
  docPrepend, docAppend, docSurround  Prepend, append, or surround the document (add header/footer)
  join  join/separator                Join lines with a space (or optional separator)

Separators:
  s/foo/bar
  s/foo/bar/
  s|foo|bar
  s{foo}bar

Line Number rules
-----------------
Using the special delimiter ':' you can apply most rules on line numbers instead of line content.

For example
  s:1:replace                      Replaces line 1 with the word "replace"
  p:1                              Only print line 1

Not all rules support this feature, but typically any rule that _could_ support it, _does_

Line numbers can be expressed as a single number, a range, an open range, a modulo operation, and a comma-separated list of rules
  p:1                              Only matches the line number (only matches line 1)
  p:%2                             Matches lines that are modulo-N (even lines)
  p:%2-1                           Matches lines that are modulo-N minus Y (odd lines)
  p:1,3,5                          Matches the listed line numbers (and only these)
  p:1-5                            Matches the range of number, inclusive (1,2,3,4,5)
  p:9-                             Matches the line number and all subsequent lines (lines 9 and onward)
  p:-9                             Matches lines up to and including the line number (lines 1-9)
  p:1-5,10-15,20,30+               Ranges and single lines can be mixed and matched

`)
}

function resetState() {
  return {
    // line-commands `on`, `after`, and `off` all share this value; toggles printing on/off
    printOn: null,
  }
}

/**
 * Performs a single substitution on the line. Use gsub to replace every instance.
 *
 * When matching line numbers, the entire line is replaced with the matching text.
 *
 * Usage:
 *     ssed sub/{pattern}
 *     ssed sub:{line-number}
 *
 * Aliases:
 *     ssed s/{pattern}
 *
 * @example using regex
 *     this is text | sub/this/that => that is text
 *
 * @example Using line numbers
 *     this
 *     is
 *     text | sub:1:that => that
 *                          is
 *                          text
 */
function substitutionRule(delim, pattern, replace) {
  if (delim === ':') {
    const lineRangeTest = toLineRangeTest(pattern)

    return (line, lineNo) => {
      if (lineRangeTest(lineNo)) {
        return replace
      }

      return line
    }
  }

  const regex = new RegExp(pattern)
  return line => line.replace(regex, replace)
}

/**
 * Replaces every match with the substitution.
 *
 * Does not support line numbers.
 *
 * Usage:
 *     ssed gsub/{pattern}
 *
 * Aliases:
 *     ssed g/{pattern}
 *
 * @example Using regex
 *     this is text | sub/t/T => This is TexT
 *     this is text | s|t|T => This is Text
 */
function globalSubstitutionRule(delim, pattern, replace) {
  if (delim === ':') {
    throw Error(`'gsub' does not support '${delim}' delimiter`)
  }

  const regex = new RegExp(pattern, 'g')
  return line => line.replace(regex, replace)
}

/**
 * Only print the matching part of the line, or print the entire line if 'pattern'
 * doesn't match.
 *
 * When matching line numbers, only the matching lines are printed (this works
 * identically to the 'print' command)
 *
 * Usage:
 *     ssed take/{pattern}
 *     ssed take:{line-number}
 *
 * Aliases:
 *     ssed t/{pattern}
 *
 * @example Using regex
 *     this is text | take/t\w+ => this
 *     this is text | t/t\w+ => this
 *     how now      | take/t\w+ => how now
 *
 * @example Using line numbers
 *     this
 *     is
 *     text | take:1 => this
 */
function takeRule(delim, pattern) {
  if (delim === ':') {
    const lineRangeTest = toLineRangeTest(pattern)

    return (line, lineNo) => {
      if (lineRangeTest(lineNo)) {
        return line
      }
    }
  }

  const regex = new RegExp(pattern)
  return line => {
    const match = line.match(regex)
    return match ? match[0] : line
  }
}

/**
 * Removes the matching part of the line, or print the entire line if 'pattern'
 * doesn't match.
 *
 * When matching line numbers, only the matching lines are removed (this works
 * identically to the 'kill' command)
 *
 * Usage:
 *     ssed rm/{pattern}
 *     ssed rm:{line-number}
 *
 * Aliases:
 *     ssed r/{pattern}
 *
 * @example Using regex
 *     this is text | rm/^\w+ is/ => text
 *
 * @example Using line numbers
 *     this
 *     is
 *     text | rm:1 => is
 *                    text
 */
function removeRule(delim, pattern) {
  if (delim === ':') {
    const lineRangeTest = toLineRangeTest(pattern)

    return (line, lineNo) => {
      if (lineRangeTest(lineNo)) {
        return
      }

      return line
    }
  }

  const regex = new RegExp(pattern)
  return line => line.replace(regex, '')
}

/**
 * Only print lines that match 'pattern'.
 *
 * When matching line numbers, only the matching lines are printed. This works
 * identically to the 'take' command.
 *
 * Usage:
 *     ssed print/{pattern}
 *     ssed print:{line-number}
 *
 * Aliases:
 *     ssed p/{pattern}
 *
 * @example Using regex
 *     this
 *     is
 *     text | p/^t => this
 *                    text
 *
 * @example Using line numbers
 *     this
 *     is
 *     text | print:2-3 => is
 *                         text
 */
function printRule(delim, pattern) {
  if (delim === ':') {
    const lineRangeTest = toLineRangeTest(pattern)

    return (line, lineNo) => {
      if (lineRangeTest(lineNo)) {
        return line
      }
    }
  }

  const regex = new RegExp(pattern)
  return line => (line.match(regex) ? line : undefined)
}

/**
 * Removes lines that match the pattern. Inverse of "print".
 *
 * Usage:
 *    ssed kill/{pattern}
 *    ssed kill:{line-number}
 *
 * Aliases:
 *    ssed k/{pattern}
 *    ssed !p/{pattern}
 *    ssed !print/{pattern}
 *
 * When matching line numbers, the matching lines are removed.
 *
 * @example Using regex
 *     this
 *     is
 *     some
 *     text | k/is => some
 *                    text
 *
 * @example Using line numbers
 *     this
 *     is
 *     text | kill:1 => is
 *                      text
 */
function killRule(delim, pattern) {
  if (delim === ':') {
    const lineRangeTest = toLineRangeTest(pattern)

    return (line, lineNo) => {
      if (lineRangeTest(lineNo)) {
        return
      }

      return line
    }
  }

  const regex = new RegExp(pattern)
  return line => (line.match(regex) ? undefined : line)
}

/**
 * Only prints unique lines. Default behaviour matches the entire line, but you can
 * specify a regular expression to only match part of the line. If the line doesn't
 * match, it isn't printed.
 *
 * Does not support line-numbers.
 *
 * Usage:
 *    ssed unique
 *    ssed unique/{pattern}
 *
 * Aliases:
 *    ssed uniq
 *
 * @example
 *     alice
 *     alice
 *     bob
 *     bob | uniq => alice
 *                   bob
 *
 * @example Using regex
 *     who is alice?
 *     what is alice?
 *     I don't know.
 *     do you know bob?
 *     does anyone know bob? | uniq/\w+\? => who is alice?
 *                                           do you know bob?
 */
function uniqueRule(delim, pattern) {
  if (delim === ':') {
    throw Error(`'uniq' does not support '${delim}' delimiter`)
  }

  const lines = new Set()
  let part = line => line
  if (pattern) {
    const regex = new RegExp(pattern)
    part = line => line.match(regex)?.[0]
  }

  return line => {
    const match = part(line)
    if (match == null) {
      return null
    }

    if (lines.has(match)) {
      lines.add(match)
      return line
    }
  }
}

/**
 * Trims whitespace from the line. Defaults to trimming whitespace on both sides,
 * but 'left' or 'right' can be specified to only trim on one side.
 *
 * Usage:
 *    ssed trim
 *    ssed trim:left
 *    ssed trim:right
 *
 * @example '|' indicates start and end of line
 *     |     line 1|
 *     |line 2     |
 *     |   line 3  | ssed trim => |line 1|
 *                                |line 2|
 *                                |line 3|
 *
 * @example
 *     |     line 1|
 *     |line 2     |
 *     |   line 3  | ssed trim:right => |     line 1|
 *                                      |line 2|
 *                                      |   line 3|
 */
function trimRule(delim, pattern) {
  let trim = line => line.trim()
  if (pattern == 'left') {
    trim = line => line.replace(/^\s+/, '')
  } else if (pattern == 'right') {
    trim = line => line.replace(/\s+$/, '')
  } else if (pattern) {
    // error
    throw Error(`Invalid: trim${delim}${pattern}`)
  }

  return line => {
    return trim(line)
  }
}

/**
 * Prepends (prefix) each line with text.
 *
 * Usage:
 *    ssed prepend/{text}
 *
 * Aliases:
 *    ssed prefix/{text}
 *
 * @example
 *     1
 *     2
 *     3
 *     4 | prepend:'line ' => line 1
 *                            line 2
 *                            line 3
 *                            line 4
 */
function prependRule(prependText) {
  return surroundRule(prependText, '')
}

/**
 * Append (suffix) each line with text.
 *
 * Usage:
 *    ssed append/{text}
 *
 * Aliases:
 *    ssed suffix/{text}
 *
 * @example
 *     1
 *     2
 *     3
 *     4 | append:' foo' => 1 foo
 *                          2 foo
 *                          3 foo
 *                          4 foo
 */
function appendRule(appendText) {
  return surroundRule('', appendText)
}

/**
 * Surround each line with text.
 *
 * Usage:
 *    ssed surround/{prepend}/{append}
 *
 * @example
 *     1
 *     2
 *     3
 *     4 | 'surround:->:<-' => ->1<-
 *                             ->2<-
 *                             ->3<-
 *                             ->4<-
 */
function surroundRule(prepend, append) {
  return line => {
    return prepend + line + append
  }
}

/**
 * Commands to turn printing on and off based on a pattern or line number.
 *
 * on: turn printing on at the matching line
 * after: turn printing on after the matching line
 * off: turn printing off at the matching line
 *
 * Usage:
 *    ssed on/{pattern}
 *    ssed on:{line-number}
 *    ssed after/{pattern}
 *    ssed off/{pattern}
 *
 * @example
 *     a
 *     b
 *     c
 *     d
 *     e
 *     f
 *     g | on/b off/d after/f => b   # starts "off", is turned on by matching 'b'
 *                               c   # still "on", turned off by matching 'd'
 *                               g   # off until 'f', then turned on starting at next line
 */
function controlPrintingRule(cmd, delim, pattern) {
  let check = (_line, _lineNo) => true
  if (delim === ':') {
    const lineRangeTest = toLineRangeTest(pattern)
    check = (_, lineNo) => lineRangeTest(lineNo)
  } else if (pattern) {
    const regex = new RegExp(pattern)
    check = line => line.match(regex)
  }

  return (line, lineNo, state) => {
    if (cmd === 'on' && (state.printOn || check(line, lineNo))) {
      state.printOn = true
    } else if (cmd === 'off' && check(line, lineNo)) {
      state.printOn = false
    }

    if (state.printOn) {
      return line
    }

    if (cmd === 'after' && check(line, lineNo)) {
      state.printOn = true
    }
  }
}

/**
 * Replaces the line with the nth group of the match.
 *
 * Does not support line-numbers.
 *
 * Usage:
 *    ssed 1/{pattern(group)}
 *    ssed 2/{pattern(group1)(group2)}
 *    ssed …/{pattern(…)}
 *
 * @example
 *     text | 1/\w(\w+)$ => ext
 *     this is text | 2/(\w+) (\w+) (\w+) => is
 */
function groupMatchRule(index, pattern, delim) {
  if (delim === ':') {
    throw Error(`'${index}' does not support '${delim}' delimiter`)
  }

  const regex = new RegExp(pattern)
  return line => {
    const match = line.match(regex)
    return match && match[index] ? match[index] : line
  }
}

function toLineRule([cmd, pattern, replace, _, delim]) {
  switch (cmd) {
    case 'sub':
    case 's':
      return substitutionRule(delim, pattern, replace)
    case 'gsub':
    case 'g':
      return globalSubstitutionRule(delim, pattern, replace)
    case 'take':
    case 't':
      return takeRule(delim, pattern)
    case 'rm':
    case 'r':
      return removeRule(delim, pattern)
    case 'print':
    case 'p':
      return printRule(delim, pattern)
    case 'kill':
    case 'k':
    case '!p':
    case '!print':
      return killRule(delim, pattern)
    case 'uniq':
    case 'unique':
      return uniqueRule(delim, pattern)
    case 'trim':
      return trimRule(delim, pattern)
    case 'prepend':
    case 'prefix':
      return prependRule(pattern)
    case 'append':
    case 'suffix':
      return appendRule(pattern)
    case 'surround':
      return surroundRule(pattern, replace)
    case 'on':
    case 'off':
    case 'after':
      return controlPrintingRule(cmd, delim, pattern)
    default:
      if (cmd.match(/^\d+$/)) {
        const index = parseInt(cmd)
        return groupMatchRule(index, pattern, delim)
      }
  }
}

function documentSortRule(pattern) {
  const regex = pattern && new RegExp(pattern)
  return lines => {
    return lines.toSorted(([a], [b]) => {
      if (regex) {
        const aMatch = a.match(regex)
        const bMatch = b.match(regex)
        if (aMatch && bMatch) {
          return aMatch[0].localeCompare(bMatch[0])
        } else {
          return 0;
        }
      }

      return a.localeCompare(b)
    })
  }
}

function documentReverseRule() {
  return lines => {
    return lines.reverse()
  }
}

function documentLineNumbersRule(pattern, replace) {
  return lines => {
    const max = lines.length
    return lines.map(([line, lineNo]) => {
      let lineNoStr = lineNo.toString()
      let pad = ' '.repeat(max.toString().length - lineNoStr.length)
      return [pad + lineNoStr + pattern + ':' + replace + line, lineNo]
    })
  }
}

function documentPrependRule(prependText) {
  return documentSurroundRule(prependText, '')
}

function documentAppendRule(appendText) {
  return documentSurroundRule('', appendText)
}

function documentSurroundRule(prependText, appendText) {
  const prependLines = prependText == '' ? [] : prependText.split('\n')
  const appendLines = appendText == '' ? [] : appendText.split('\n')
  const prependLength = prependLines.length

  return lines => {
    return prependLines
      .map((line, index) => [line, index + 1])
      .concat(
        lines.map(([line, lineNo]) => {
          return [line, prependLength + lineNo]
        }),
      )
      .concat(
        appendLines.map((line, index) => [
          line,
          prependLength + lines.length + index + 1,
        ]),
      )
  }
}

function documentJoinLinesRule(joiner) {
  return lines => {
    return [[lines.map(([line]) => line).join(joiner || ' ')]]
  }
}

function documentLinesRule(lineRules) {
  return lines => {
    const state = resetState()

    return lines.flatMap(([line, lineNo]) => {
      for (const lineRule of lineRules) {
        line = lineRule(line, lineNo, state)
        if (line == null) {
          return []
        }
      }

      return [[line, lineNo]]
    })
  }
}

function toDocumentRule([cmd, pattern, replace]) {
  if (cmd === 'sort') {
    return documentSortRule(pattern)
  } else if (cmd === 'reverse') {
    return documentReverseRule()
  } else if (cmd === 'docprepend' || cmd === 'docprefix') {
    return documentPrependRule(pattern)
  } else if (cmd === 'docappend' || cmd === 'docsuffix') {
    return documentAppendRule(pattern)
  } else if (cmd === 'docsurround') {
    return documentSurroundRule(pattern, replace)
  } else if (cmd === 'line') {
    return documentLineNumbersRule(pattern, replace)
  } else if (cmd === 'join') {
    return documentJoinLinesRule(pattern)
  } else if (cmd === 'help') {
    help()
    process.exit(0);
  }
}

function toLineRangeTest(pattern) {
  if (pattern === '*') {
    return () => true
  }

  if (pattern.includes(',')) {
    const rules = pattern.split(',').map(rule => toLineRangeTest(rule))
    return lineNo => rules.some(fn => fn(lineNo))
  }

  if (pattern.startsWith('%')) {
    let modulus = pattern.slice(1)
    if (modulus.includes('-')) {
      const [mod, offset] = modulus.split('-', 2).map(Number)
      return lineNo => (lineNo + offset) % mod === 0
    } else {
      return lineNo => lineNo % Number(modulus) === 0
    }
  }

  if (pattern.includes('-')) {
    const [start, stop] = pattern.split('-', 2).map((number, index) => {
      if (number === '' && index === 0) {
        return 1
      } else if (number === '' && index === 1) {
        return Infinity
      } else {
        return Number(number)
      }
    })

    return lineNo => lineNo >= start && lineNo <= stop
  }

  return lineNo => lineNo === Number(pattern)
}

function lineStream(inputStream, transform = undefined) {
  const stdin = new EventEmitter()
  let buffer = ''
  let closed = false

  function emit(line) {
    if (closed) {
      return
    }

    if (transform) {
      line = transform(line)
    }

    if (line !== undefined) {
      stdin.emit('line', line)
    }
  }

  inputStream.resume()
  inputStream.setEncoding('utf-8')
  inputStream.on('open', function () {
    stdin.emit('open')
  })
  inputStream.on('data', function (chunk) {
    buffer += chunk
    const lines = buffer.split('\n')
    buffer = lines.pop()
    lines.forEach(line => emit(line))
  })

  inputStream.on('end', () => {
    if (buffer.length > 0) emit(buffer)
    let autoclose = true
    function keepOpen() {
      autoclose = false
    }
    function close() {
      stdin.emit('close')
    }
    stdin.emit('end', keepOpen, close)
    if (autoclose) {
      close()
    }
  })

  stdin.pause = inputStream.pause.bind(inputStream)
  stdin.close = () => {
    closed = true
    inputStream.pause()
  }
  stdin.pipe = transform => {
    return lineStream(stdin, transform)
  }

  return stdin
}

function parseOption(arg) {
  let option
  if (arg.startsWith('--')) {
    ;[option] = arg.slice(2).match(/^([\w-]+)/) ?? [option]
  } else if (arg.startsWith('-')) {
    ;[option] = arg.slice(1).match(/^(\w+)/) ?? [option]
    return option.split('').map(opt => parseOption(`--${opt}`))
  } else {
    return
  }

  switch (option) {
    case 'h':
    case 'help': {
      help()
      process.exit(0)
    }
    case 'no-color':
    case 'color': {
      return {
        color: option === 'color',
      }
    }
    case 'n':
    case 'no-dry-run':
    case 'dry-run': {
      return {
        dryRun: option === 'dry-run',
      }
    }
    case 'no-diff':
    case 'diff': {
      return {
        diff: option === 'diff',
      }
    }
    case 'no-interactive':
    case 'interactive': {
      return {
        interactive: option === 'interactive',
      }
    }
    case 'no-write':
    case 'write': {
      const [, writeToFile] = arg.split('=', 2)

      return {
        write: option === 'write',
        diff: option === 'write',
        writeToFile,
      }
    }
    case 'input': {
      const [, file] = arg.split('=', 2)
      if (file === undefined) {
        return {inputFromFile: true, input: null}
      } else {
        switch (file) {
          case 'stdin':
            return {input: process.stdin}
          default:
            const files = file.split(',')
            if (files.length > 1) {
              return {
                inputFromFile: true,
                input: files.map(file => {
                  if (fs.existsSync(file)) {
                    return file
                  } else {
                    throw Error(`File does not exist: ${file}`)
                  }
                }),
              }
            } else {
              if (fs.existsSync(file)) {
                return {input: file, inputFromFile: true}
              } else {
                throw Error(`File does not exist: ${file}`)
              }
            }
        }
      }
      break
    }
    default:
      throw Error(`Invalid option: ${option}`)
  }
}

function main(args) {
  let options = {
    input: process.stdin,
    inputFromFile: false,
    interactive: false,
    write: false,
    writeToFile: null,
    diff: false,
    diffHeader: '',
    diffContext: 3, // number of lines to print before and after diffs
    color: process.stdout.isTTY,
    print: (line, nl = true) => {
      process.stdout.write(line + (nl ? '\n' : ''))
    },
  }

  let lineRules = []
  const documentRules = []

  const rules = []
  for (const arg of args) {
    const option = parseOption(arg)
    if (option !== undefined) {
      options = {...options, ...option}
    } else {
      rules.push(arg)
    }
  }

  if (options.inputFromFile && typeof options.input !== 'string') {
    args = args.filter(arg => !arg.startsWith('--input'))

    const files = []
    function next() {
      const file = files.pop()
      if (!file) {
        return
      }

      main([`--input=${file}`, ...args])
        .on('open', () => {
          if (!options.diff) {
            options.print(yellow(`ssed: ${file}`))
          }
        })
        .on('close', next)
    }

    if (options.input === null) {
      const stdin = lineStream(process.stdin)
      // treat stdin as list of files

      stdin
        .on('line', file => {
          files.push(file)
        })
        .on('close', () => {
          next()
        })
    } else if (Array.isArray(options.input)) {
      files.push(...options.input)
      next()
    }

    return
  } else if (options.inputFromFile) {
    options.diffHeader = `diff ${options.input}
--- ${options.input}
+++ ssed ${args.map(escapeShell).join(' ')}`

    const file = options.input
    if (options.write && !options.writeToFile && file !== process.stdin) {
      options.writeToFile = file
    } else if (options.writeToFile) {
      options.writeToFile = options.writeToFile.replace('%', file)
    }

    options.input = fs.createReadStream(file)
  }

  for (const rule of rules) {
    const parsed = parseRuleArgs(rule)

    let lineRule, documentRule
    if ((lineRule = toLineRule(parsed))) {
      lineRules.push(lineRule)
    } else if ((documentRule = toDocumentRule(parsed))) {
      if (lineRules.length) {
        documentRules.push(documentLinesRule(lineRules))
        lineRules = []
      }

      documentRules.push(documentRule)
    } else {
      throw Error(`Invalid rule: ${rule}`)
    }
  }

  if (lineRules.length && documentRules.length) {
    documentRules.push(documentLinesRule(lineRules))
    lineRules = []
  }

  const inputStream = lineStream(options.input)
  const originalLines = []
  let lines = []
  let lineNo = 0

  // if (
  //   we only have line rules,
  //   no document rules,
  //   and we're not diffing the output
  // ), then: we perform a "stream edit".
  //
  // 1. create a state for the line rules
  // 2. don't store the output in lines
  // 3. output immediately
  const state = resetState()
  return inputStream
    .on('line', line => {
      const original = line
      originalLines.push(original)

      lineNo += 1

      for (const lineRule of lineRules) {
        line = lineRule(line, lineNo, state)
        if (line == null) {
          break
        }
      }


      if (!options.diff && documentRules.length === 0 && line != null) {
        options.print(line)
      } else if (line != null) {
        lines.push([line, lineNo])
      }
    })
    .on('end', (keepOpen, close) => {
      for (const documentRule of documentRules) {
        lines = documentRule(lines)
        if (!lines?.length) {
          break
        }

        // reset line numbers between documentRules
        lines = lines.map(([line], index) => [line, index + 1])
      }

      lines = lines?.map(([line]) => line) ?? []

      if (options.diff) {
        let lineRun = {
          hasDiff: false,
          lineNumber: 0,
          before: [],
          prev: [],
          next: [],
          after: [],
        }

        function flush(EOF = false) {
          const {before, prev, next, after, lineNumber} = lineRun

          if (!EOF && lineNumber === -1) {
            return
          }

          if (!EOF && after.length < options.diffContext) {
            return
          }

          if (EOF && prev.length === 0 && next.length === 0) {
            return
          }

          if (!lineRun.hasDiff) {
            options.print(yellow(options.diffHeader, options.color))
          }

          const firstIndex = Math.max(before.length - options.diffContext, 0)
          options.print(
            magenta(
              `@@ -${lineNumber + firstIndex},0 +${
                lineNumber + firstIndex
              },0 @@`,
              options.color,
            ),
          )
          for (const line of before.slice(firstIndex)) {
            options.print(` ${line}`)
          }

          for (const line of prev) {
            options.print(red(`-${line}`, options.color))
          }
          for (const line of next) {
            options.print(green(`+${line}`, options.color))
          }

          for (const line of after) {
            options.print(` ${line}`)
          }

          lineRun = {
            before: [],
            prev: [],
            next: [],
            after: [],
            hasDiff: true,
            lineNumber: -1,
          }
        }

        function push(prev, next, lineNumber) {
          if (lineRun.lineNumber === -1) {
            lineRun.lineNumber = lineNumber
          }

          if (prev === next) {
            if (lineRun.prev.length) {
              lineRun.after.push(next)
            } else {
              lineRun.before.push(next)
            }

            flush(false)
          } else {
            lineRun.prev.push(prev)
            lineRun.next.push(next)
          }
        }

        originalLines.forEach((original, lineIndex) => {
          const line = lines[lineIndex] ?? ''

          push(original, line, lineIndex)
        })

        flush(true)

        if (options.write && lineRun.hasDiff) {
          if (options.interactive) {
            if (!process.stdin.isTTY) {
              options.print(
                red(
                  `Cannot run interactively – input is coming from stdin`,
                  options.color,
                ),
              )
              process.exit(1)
            }

            options.print(
              yellow(
                `Write changes to ${options.writeToFile}? [Yn] `,
                options.color,
              ),
              false,
            )
            keepOpen()

            const stdin = lineStream(process.stdin)
            stdin.on('line', line => {
              if (line === '' || line === 'y' || line === 'yes') {
                if (options.dryRun) {
                  options.print(
                    yellow(`Dry Run: ${options.writeToFile}`, options.color),
                  )
                } else {
                  writeLinesToFile(lines, options.writeToFile)
                }
              } else if (line === 'n') {
                options.print(
                  yellow(`Skipping ${options.writeToFile}`, options.color),
                )
              } else {
                options.print(
                  red(`Unknown response '${line}'. Aborting`, options.color),
                )
                process.exit(1)
              }
              stdin.close()
              close()
            })
          } else {
            if (options.dryRun) {
              options.print(
                yellow(`Dry Run: ${options.writeToFile}`, options.color),
              )
            } else {
              writeLinesToFile(lines, options.writeToFile)
            }
          }
        }
      } else {
        for (const line of lines) {
          options.print(line)
        }
      }
    })
}

try {
  // remove 'node' and 'ssed' from argv
  main(process.argv.slice(2))
} catch (e) {
  process.stderr.write(`ssed: ${e.message}\n`)
}

function ansi(code, input) {
  return `\x1b[${code}m${input}\x1b[0m`
}

function red(input, enabled) {
  return enabled ? ansi('1;31', input) : input
}

function green(input, enabled) {
  return enabled ? ansi('1;32', input) : input
}

function yellow(input, enabled) {
  return enabled ? ansi('38;5;227', input) : input
}

function magenta(input, enabled) {
  return enabled ? ansi('1;35', input) : input
}

function escapeShell(arg) {
  if (arg.match(/[;\\]/)) {
    return '"' + arg.replaceAll('\\', '\\\\').replaceAll('"', '\\"') + '"'
  }

  return arg
}

function writeLinesToFile(lines, file) {
  if (!file) {
    return
  }

  if (Array.isArray(lines)) {
    lines = lines.join('\n')
  }

  fs.writeFileSync(file, lines)
}
