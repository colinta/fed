#!/usr/bin/env node
const fs = require('fs')
const EventEmitter = require('events')
const {exec, execSync} = require('child_process');

process.stdout.on('error', function(err) {
  if (err.code === 'EPIPE') {
    exec('stty echo', () => {
      process.exit(0);
    })
  }
});

function requireArg(name, value) {
  if (value == null) {
    throw Error(`Missing argument: ${name}`)
  }
}

/**
 * Performs a single substitution on every line that matches. Use gsub to replace
 * multiple substitutions perline.
 *
 * When matching line numbers, the entire line is replaced with the matching text.
 *
 * Usage:
 *     ssed sub/{pattern}
 *     ssed sub:{line-number}
 *
 * Aliases:
 *     ssed s/{pattern}
 *
 * @example using regex
 *     this is text | sub/this/that => that is text
 *
 * @example Using line numbers
 *     this
 *     is
 *     text | sub:1:that => that
 *                          is
 *                          text
 */
function substitutionRule(delim, pattern, replace) {
  requireArg('pattern', pattern)
  requireArg('replace', replace)

  if (delim === ':') {
    const lineRangeTest = toLineRangeTest(pattern)

    return (line, lineNo) => {
      if (lineRangeTest(lineNo)) {
        return replace
      }

      return line
    }
  }

  const regex = new RegExp(pattern)
  return line => line.replace(regex, replace)
}

/**
 * Replaces every match with the substitution.
 *
 * Does not support line numbers.
 *
 * Usage:
 *     ssed gsub/{pattern}
 *
 * Aliases:
 *     ssed g/{pattern}
 *
 * @example Using regex
 *     this is text | sub/t/T => This is TexT
 *     this is text | s|t|T => This is Text
 */
function globalSubstitutionRule(delim, pattern, replace) {
  requireArg('pattern', pattern)
  requireArg('replace', replace)

  if (delim === ':') {
    throw Error(`'gsub' does not support '${delim}' delimiter`)
  }

  const regex = new RegExp(pattern, 'g')
  return line => line.replace(regex, replace)
}

/**
 * Only print the matching part of the line, or print the entire line if 'pattern'
 * doesn't match.
 *
 * When matching line numbers, only the matching lines are printed (this works
 * identically to the 'print' command)
 *
 * Usage:
 *     ssed take/{pattern}
 *     ssed take:{line-number}
 *
 * Aliases:
 *     ssed t/{pattern}
 *
 * @example Using regex
 *     this is text | take/t\w+ => this
 *     this is text | t/t\w+ => this
 *     how now      | take/t\w+ => how now
 *
 * @example Using line numbers
 *     this
 *     is
 *     text | take:1 => this
 */
function takeRule(delim, pattern) {
  requireArg('pattern', pattern)

  if (delim === ':') {
    const lineRangeTest = toLineRangeTest(pattern)

    return (line, lineNo) => {
      if (lineRangeTest(lineNo)) {
        return line
      }
    }
  }

  const regex = new RegExp(pattern)
  return line => {
    const match = line.match(regex)
    return match ? match[0] : line
  }
}

/**
 * Removes the matching part of the line, or print the entire line if 'pattern'
 * doesn't match.
 *
 * When matching line numbers, only the matching lines are removed (this works
 * identically to the 'kill' command)
 *
 * Usage:
 *     ssed rm/{pattern}
 *     ssed rm:{line-number}
 *
 * Aliases:
 *     ssed r/{pattern}
 *
 * @example Using regex
 *     this is text | rm/^\w+ is/ => text
 *
 * @example Using line numbers
 *     this
 *     is
 *     text | rm:1 => is
 *                    text
 */
function removeRule(delim, pattern) {
  requireArg('pattern', pattern)

  if (delim === ':') {
    const lineRangeTest = toLineRangeTest(pattern)

    return (line, lineNo) => {
      if (lineRangeTest(lineNo)) {
        return
      }

      return line
    }
  }

  const regex = new RegExp(pattern)
  return line => line.replace(regex, '')
}

/**
 * Only print lines that match 'pattern'.
 *
 * When matching line numbers, only the matching lines are printed. This works
 * identically to the 'take' command.
 *
 * Usage:
 *     ssed print/{pattern}
 *     ssed print:{line-number}
 *
 * Aliases:
 *     ssed p/{pattern}
 *
 * @example Using regex
 *     this
 *     is
 *     text | p/^t => this
 *                    text
 *
 * @example Using line numbers
 *     this
 *     is
 *     text | print:2-3 => is
 *                         text
 */
function printRule(delim, pattern) {
  requireArg('pattern', pattern)

  if (delim === ':') {
    const lineRangeTest = toLineRangeTest(pattern)

    return (line, lineNo) => {
      if (lineRangeTest(lineNo)) {
        return line
      }
    }
  }

  const regex = new RegExp(pattern)
  return line => (line.match(regex) ? line : undefined)
}

/**
 * Removes lines that match the pattern. Inverse of "print".
 *
 * Usage:
 *    ssed kill/{pattern}
 *    ssed kill:{line-number}
 *
 * Aliases:
 *    ssed k/{pattern}
 *    ssed !p/{pattern}
 *    ssed !print/{pattern}
 *
 * When matching line numbers, the matching lines are removed.
 *
 * @example Using regex
 *     this
 *     is
 *     some
 *     text | k/is => some
 *                    text
 *
 * @example Using line numbers
 *     this
 *     is
 *     text | kill:1 => is
 *                      text
 */
function killRule(delim, pattern) {
  requireArg('pattern', pattern)

  if (delim === ':') {
    const lineRangeTest = toLineRangeTest(pattern)

    return (line, lineNo) => {
      if (lineRangeTest(lineNo)) {
        return
      }

      return line
    }
  }

  const regex = new RegExp(pattern)
  return line => (line.match(regex) ? undefined : line)
}

/**
 * Only prints unique lines. Default behaviour matches the entire line, but you can
 * specify a regular expression to only match part of the line. If the line doesn't
 * match, it isn't printed.
 *
 * Does not support line-numbers.
 *
 * Usage:
 *    ssed unique
 *    ssed unique/{pattern}
 *
 * Aliases:
 *    ssed uniq
 *
 * @example
 *     alice
 *     alice
 *     bob
 *     bob | uniq => alice
 *                   bob
 *
 * @example Using regex
 *     who is alice?
 *     what is alice?
 *     I don't know.
 *     do you know bob?
 *     does anyone know bob? | uniq/\w+\? => who is alice?
 *                                           do you know bob?
 */
function uniqueRule(delim, pattern) {
  requireArg('pattern', pattern)

  if (delim === ':') {
    throw Error(`'uniq' does not support '${delim}' delimiter`)
  }

  const lines = new Set()
  let part = line => line
  if (pattern) {
    const regex = new RegExp(pattern)
    part = line => line.match(regex)?.[0]
  }

  return line => {
    const match = part(line)
    if (match == null) {
      return null
    }

    if (lines.has(match)) {
      lines.add(match)
      return line
    }
  }
}

/**
 * Trims whitespace from the line. Defaults to trimming whitespace on both sides,
 * but 'left' or 'right' can be specified to only trim on one side.
 *
 * Usage:
 *    ssed trim
 *    ssed trim:left
 *    ssed trim:right
 *
 * @example '|' indicates start and end of line
 *     |     line 1|
 *     |line 2     |
 *     |   line 3  | ssed trim => |line 1|
 *                                |line 2|
 *                                |line 3|
 *
 * @example
 *     |     line 1|
 *     |line 2     |
 *     |   line 3  | ssed trim:right => |     line 1|
 *                                      |line 2|
 *                                      |   line 3|
 */
function trimRule(delim, pattern) {
  requireArg('pattern', pattern)

  let trim = line => line.trim()
  if (pattern === 'left') {
    trim = line => line.replace(/^\s+/, '')
  } else if (pattern === 'right') {
    trim = line => line.replace(/\s+$/, '')
  } else if (pattern && pattern !== 'both') {
    // error
    throw Error(`Invalid: trim${delim}${pattern}`)
  }

  return line => trim(line)
}

/**
 * Prepends (prefix) each line with text.
 *
 * Usage:
 *    ssed prepend/{text}
 *
 * Aliases:
 *    ssed prefix/{text}
 *
 * @example
 *     1
 *     2
 *     3
 *     4 | prepend:'line ' => line 1
 *                            line 2
 *                            line 3
 *                            line 4
 */
function prependRule(prependText) {
  return surroundRule(prependText, '')
}

/**
 * Append (suffix) each line with text.
 *
 * Usage:
 *    ssed append/{text}
 *
 * Aliases:
 *    ssed suffix/{text}
 *
 * @example
 *     1
 *     2
 *     3
 *     4 | append:' foo' => 1 foo
 *                          2 foo
 *                          3 foo
 *                          4 foo
 */
function appendRule(appendText) {
  return surroundRule('', appendText)
}

/**
 * Surround each line with text.
 *
 * Usage:
 *    ssed surround/{prepend}/{append}
 *
 * @example
 *     1
 *     2
 *     3
 *     4 | 'surround:->:<-' => ->1<-
 *                             ->2<-
 *                             ->3<-
 *                             ->4<-
 */
function surroundRule(prepend, append) {
  return line => prepend + line + append
}

/**
 * Commands to turn printing on and off based on a pattern or line number.
 *
 * on:     turn printing on at the matching line
 * after:  turn printing on after the matching line
 * off:    turn printing off at the matching line
 * toggle: printing starts on, toggles on matching lines
 *
 * Usage:
 *    ssed on/{pattern}
 *    ssed on:{line-number}
 *    ssed after/{pattern}
 *    ssed off/{pattern}
 *    ssed toggle/{pattern}
 *
 * @example
 *     a
 *     b
 *     c
 *     d
 *     e
 *     f
 *     g | on/b off/d after/f => b   # starts "off", is turned on by matching 'b'
 *                               c   # still "on", turned off by matching 'd'
 *                               g   # off until 'f', then turned on starting at next line
 */
function controlPrintingRule(cmd, delim, pattern) {
  requireArg('pattern', pattern)

  let check = (_line, _lineNo) => true
  if (delim === ':') {
    const lineRangeTest = toLineRangeTest(pattern)
    check = (_, lineNo) => lineRangeTest(lineNo)
  } else {
    const regex = new RegExp(pattern)
    check = line => Boolean(line.match(regex))
  }

  return {
    beforeEach(line, state) {
      state.suppressedLine = null
    },
    line: (line, lineNo, state) => {
      if (cmd === 'on' && state.printOn == null) {
        state.printOn = false
      } else if (cmd === 'toggle' && state.printOn == null) {
        state.printOn = true
      } else if (cmd === 'off' && state.printOn == null) {
        state.printOn = true
      }

      if (
        cmd === 'on' &&
        state.suppressedLine != null &&
        !state.printOn &&
        check(state.suppressedLine, lineNo)
      ) {
        state.printOn = true
        line = state.suppressedLine
      } else if (cmd === 'on' && (state.printOn || check(line, lineNo))) {
        state.printOn = true
      } else if (cmd === 'off' && check(line, lineNo)) {
        state.printOn = false
      } else if (cmd === 'toggle' && check(line, lineNo)) {
        state.printOn = !state.printOn
      }

      if (state.printOn) {
        state.suppressedLine = null
        return line
      } else {
        state.suppressedLine ??= line
      }

      if (
        cmd === 'after' &&
        state.suppressedLine != null &&
        !state.printOn &&
        check(state.suppressedLine, lineNo)
      ) {
        state.printOn = true
      } else if (cmd === 'after' && check(line, lineNo)) {
        state.printOn = true
      }
    },
    after(state) {},
  }
}

/**
 * Replaces the pattern with the nth group of the match. If no pattern is given,
 * this command works like `awk {print $N}`
 *
 * Does not support line-numbers.
 *
 * Usage:
 *    # for every line that matches pattern, replace the Nth regex group
 *    ssed 1/{pattern(group1)}
 *    ssed 2/{pattern(group1)(group2)}
 *    ssed …/{pattern(…)}
 *
 *    # print the first "column" (columns are separated by whitespace, quotes are
 *    # ignored)
 *    ssed 1
 *
 * @example
 *     text | 1/\w(\w+)$ => ext
 *     this is text | 2/(\w+) (\w+) (\w+) => is
 */
function groupMatchRule(index, delim, pattern) {
  if (delim === ':') {
    throw Error(`'${index}' does not support '${delim}' delimiter`)
  }

  if (!pattern) {
    return line => {
      const match = line.split(/\s+/, index)
      return match.length >= index - 1 ? match[index - 1] : line
    }
  }

  const regex = new RegExp(pattern)
  return line => {
    const match = line.match(regex)
    return match && match[index] ? match[index] : line
  }
}

/**
 * A straightforward 'awk' feature: separate line on whitespace and print certain columns.
 *
 * Usage:
 *    # Use default separator (\s+) and print columns 1,3,2
 *    ssed cols//1,3,2
 *
 *    # Split lines by ':' and print columns 1 and 5
 *    ssed cols/:/1,5
 *
 * @example
 *     this    is    text | cols//2,1,3 => is this text
 *     1:bb:3:4:Z | cols/:/1,3,2 => 1 3 bb
 */
function columnsRule(delim, pattern, replace) {
  requireArg('pattern', pattern)
  requireArg('replace', replace)

  if (delim === ':') {
    throw Error(`'cols' does not support '${delim}' delimiter`)
  }

  const columns = replace.split(',').map(Number)
  const regex = pattern === '' ? /\s+/ : new RegExp(pattern)
  return line => {
    const match = line.match(regex)
    if (match) {
      return columns.map(index => match[index - 1] ?? '').join(' ')
    }
  }
}

function toLineRule([cmd, pattern, replace, _rest, delim]) {
  let rule
  switch (cmd) {
    case 'sub':
    case 's':
      rule = substitutionRule(delim, pattern, replace)
      break
    case 'gsub':
    case 'g':
      rule = globalSubstitutionRule(delim, pattern, replace)
      break
    case 'take':
    case 't':
      rule = takeRule(delim, pattern)
      break
    case 'rm':
    case 'r':
      rule = removeRule(delim, pattern)
      break
    case 'print':
    case 'p':
      rule = printRule(delim, pattern)
      break
    case 'kill':
    case 'k':
    case '!p':
    case '!print':
      rule = killRule(delim, pattern)
      break
    case 'uniq':
    case 'unique':
      rule = uniqueRule(delim, pattern)
      break
    case 'trim':
      rule = trimRule(delim, pattern)
      break
    case 'prepend':
    case 'prefix':
      rule = prependRule(pattern)
      break
    case 'append':
    case 'suffix':
      rule = appendRule(pattern)
      break
    case 'surround':
      rule = surroundRule(pattern, replace)
      break
    case 'on':
    case 'off':
    case 'after':
    case 'toggle':
      rule = controlPrintingRule(cmd, delim, pattern)
      break
    case 'cols':
      rule = columnsRule(delim, pattern, replace)
      break
    default:
      if (cmd.match(/^\d+$/)) {
        const index = parseInt(cmd)
        rule = groupMatchRule(index, delim, pattern)
      }
      break
  }

  if (rule instanceof Function) {
    return {line: rule}
  }

  return rule
}

function documentSortRule(pattern) {
  const regex = pattern && new RegExp(pattern)
  return documentLines => {
    return documentLines.toSorted(([a], [b]) => {
      if (regex) {
        const aMatch = a.match(regex)
        const bMatch = b.match(regex)
        if (aMatch && bMatch) {
          return aMatch[0].localeCompare(bMatch[0])
        } else {
          return 0
        }
      }

      return a.localeCompare(b)
    })
  }
}

function documentReverseRule() {
  return documentLines => documentLines.toReversed()
}

function documentLineNumbersRule(pattern, replace) {
  return documentLines => {
    const max = documentLines.length.toString().length
    return documentLines.map(([line, lineNo]) => {
      let lineNoStr = lineNo.toString()
      let pad
      if (replace) {
        pad = '0'.repeat(Math.max(Number(replace), max) - lineNoStr.length)
      } else {
        pad = ' '.repeat(max - lineNoStr.length)
      }
      const joiner = pattern ?? ':'
      return pad + lineNoStr + joiner + line
    })
  }
}

/**
 * Similar to the line substitution rule, but the substituted text is "spread"
 * across all the lines that match.
 */
function documentSubstituteLinesRule(pattern, replace, delim) {
  requireArg('pattern', pattern)

  const replaceLines = replace.split('\n')
  let index = 0
  let test

  if (delim === ':') {
    check = toLineRangeTest(pattern)
  } else {
    const regex = new RegExp(pattern)
    check = line => line.match(regex)
  }

  return documentLines => {
    const matchedLineNumbers = []
    // find all the lines that match, put into matchedLineNumbers
    // if (matchedLineNumbers >= replaceLines) {
    //   remove extra matched lines
    // } else (matchedLineNumbers < replaceLines) {
    //   add matched lines 1:1 with replaceLines until we
    //   get to the last matched line, then insert all
    //   remaining lines
    // }
    documentLines.forEach(([line, lineNo]) => {
      if (check(lineNo)) {
        matchedLineNumbers.push(lineNo)
      }
    })

    return documentLines.flatMap(([line, lineNo]) => {
      if (matchedLineNumbers.length && matchedLineNumbers[0] === lineNo) {
        matchedLineNumbers.shift()
        if (matchedLineNumbers.length === 0) {
          return replaceLines
        } else {
          const nextLine = replaceLines.shift()
          if (nextLine == null) {
            return []
          } else {
            return [nextLine]
          }
        }
      }

      return [line]
    })
  }
}


/**
 * Similar to the line substitution rule, but the substituted text is "spread"
 * across all the lines that match.
 */
function documentExecRule() {
  return (lines, _, options) => {
    const input = lines.map(([line]) => line).join('\n')

    if (options.dryRun) {
      return input.split('\n')
    }

    return execSync(input).toString('utf-8').split('\n')
  }
}

function documentPrependRule(prependText) {
  return documentSurroundRule(prependText, '')
}

function documentAppendRule(appendText) {
  return documentSurroundRule('', appendText)
}

function documentSurroundRule(prependText, appendText) {
  const prependLines = prependText == '' ? [] : prependText.split('\n')
  const appendLines = appendText == '' ? [] : appendText.split('\n')
  const prependLength = prependLines.length

  return documentLines => {
    return prependLines
      .map((line, index) => line)
      .concat(
        documentLines.map(([line, lineNo]) => {
          return line
        }),
      )
      .concat(appendLines)
  }
}

function documentJoinLinesRule(joiner) {
  return documentLines => documentLines.map(([line]) => line).join(joiner || ' ')
}

function documentLinesRule(lineRules) {
  return (documentLines, _, options) => {
    const state = resetState()

    for (const lineRule of lineRules) {
      lineRule.before?.(state)
    }

    const inputLines = [...documentLines].map(([line]) => line)
    const isLastLineBlank = inputLines.at(-1) === ''
    if (isLastLineBlank) {
      inputLines.pop()
    }

    const retLines = []
    processLines(
      state,
      true,
      lineRules,
      options,
      retLines,
      inputLines,
    )

    for (const lineRule of lineRules) {
      lineRule.after?.(state)
    }

    if (isLastLineBlank) {
      retLines.push('')
    }

    return retLines
  }
}

function toDocumentRule([cmd, pattern, replace, _rest, delim]) {
  switch (cmd) {
    case 'sort':
      return documentSortRule(pattern)
    case 'reverse':
      return documentReverseRule()
    case 'docprepend':
    case 'docprefix':
      return documentPrependRule(pattern)
    case 'docappend':
    case 'docsuffix':
      return documentAppendRule(pattern)
    case 'docsurround':
      return documentSurroundRule(pattern, replace)
    case 'line':
      return documentLineNumbersRule(pattern, replace)
    case 'join':
      return documentJoinLinesRule(pattern)
    case 'sl':
    case 'sublines':
      return documentSubstituteLinesRule(pattern, replace, delim)
    case 'exec':
      return documentExecRule()
    case 'help':
      help()
      process.exit(0)
  }
}

function toLineRangeTest(pattern) {
  requireArg('pattern', pattern)

  if (pattern === '*') {
    return () => true
  }

  if (pattern.includes(',')) {
    const rules = pattern.split(',').map(rule => toLineRangeTest(rule))
    return lineNo => rules.some(fn => fn(lineNo))
  }

  if (pattern.startsWith('%')) {
    let modulus = pattern.slice(1)
    if (modulus.includes('-')) {
      const [mod, offset] = modulus.split('-', 2).map(Number)
      return lineNo => (lineNo + offset) % mod === 0
    } else {
      return lineNo => lineNo % Number(modulus) === 0
    }
  }

  if (pattern.includes('+')) {
    throw 'Invalid line range symbol `+`'
  }

  if (pattern.includes('-')) {
    const [start, stop] = pattern.split('-', 2).map((number, index) => {
      if (number === '' && index === 0) {
        return 1
      } else if (number === '' && index === 1) {
        return Infinity
      } else {
        return Number(number)
      }
    })

    return lineNo => lineNo >= start && lineNo <= stop
  }

  return lineNo => lineNo === Number(pattern)
}

function lineStream(inputStream, transform = undefined) {
  const stdin = new EventEmitter()
  let buffer = ''
  let closed = false

  function emit(line) {
    if (closed) {
      return
    }

    if (transform) {
      line = transform(line)
    }

    if (line !== undefined) {
      stdin.emit('line', line)
    }
  }

  inputStream.on('open', function () {
    stdin.emit('open')
  })
  inputStream.on('data', function (chunk) {
    buffer += chunk
    const lines = buffer.split('\n')
    buffer = lines.pop()
    lines.forEach(line => emit(line))
  })

  inputStream.on('end', () => {
    emit(buffer)
    let autoclose = true
    function keepOpen() {
      autoclose = false
    }
    function close() {
      stdin.emit('close')
    }
    stdin.emit('end', keepOpen, close)
    if (autoclose) {
      close()
    }
  })

  inputStream.resume()
  inputStream.setEncoding('utf-8')

  stdin.pause = inputStream.pause.bind(inputStream)
  stdin.close = () => {
    closed = true
    inputStream.pause()
  }
  stdin.pipe = transform => {
    return lineStream(stdin, transform)
  }

  return stdin
}

function parseOption(options, arg, args) {
  let option
  if (arg.startsWith('--')) {
    ;[option] = arg.slice(2).match(/^([\w-]+)/) ?? [option]
  } else if (arg.startsWith('-')) {
    ;[option] = arg.slice(1).match(/^(\w+)/) ?? [option]
    return option.split('').map(opt => parseOption(options, `--${opt}`, args))
  } else {
    return
  }

  switch (option) {
    case 'h':
    case 'help': {
      help()
      process.exit(0)
    }
    case 'no-color':
    case 'color': {
      return {
        color: option === 'color',
      }
    }
    case 'n':
    case 'no-dry-run':
    case 'dry-run': {
      return {
        dryRun: option === 'dry-run',
      }
    }
    case 'no-diff':
    case 'diff': {
      return {
        diff: option === 'diff',
      }
    }
    case 'no-interactive':
    case 'interactive': {
      return {
        interactive: option === 'interactive',
      }
    }
    case 'no-write':
    case 'write': {
      const [, writeToFile] = arg.split('=', 2)

      return {
        write: option === 'write',
        diff: option === 'write',
        writeToFile,
      }
    }
    case 'no-input':
      return {inputFromFile: false, input: process.stdin}
    case 'ls':
      return {inputFromFile: true, input: null}
    case 'input': {
      let file
      if (arg.match(/^--input=/)) {
        [, file] = arg.split('=', 2)
      } else {
        file = args.shift()
      }

      const files = file.split(',')
      const prevFiles = Array.isArray(options.input) ? options.input : []
      if (files.length > 1) {
        return {
          inputFromFile: true,
          input: [
            ...prevFiles,
            files.map(file => {
              if (fs.existsSync(file)) {
                return file
              } else {
                throw Error(`File does not exist: ${file}`)
              }
            }),
          ],
        }
      } else {
        if (fs.existsSync(file)) {
          return {inputFromFile: true, input: prevFiles.length ? [...prevFiles, file] : file}
        } else {
          throw Error(`File does not exist: ${file}`)
        }
      }
      break
    }
    default:
      throw Error(`Invalid option: ${option}`)
  }
}

function processLines(
  state,
  hasDocumentRules,
  lineRules,
  options,
  lines,
  linesBuffer,
) {
  for (let line of linesBuffer) {
    state.lineNumber += 1

    for (const lineRule of lineRules) {
      lineRule.beforeEach?.(line, state)
    }

    for (const lineRule of lineRules) {
      line = lineRule.line(line, state.lineNumber, state)

      if (line == null) {
        break
      }
    }

    for (const lineRule of lineRules) {
      lineRule.afterEach?.(line, state)
    }

    if (line != null) {
      if (!options.diff && !hasDocumentRules) {
        options.print(line)
      } else {
        lines.push(line)
      }
    }
  }
}

function main(args, options = {}) {
  options = {...options,
    input: process.stdin,
    inputFromFile: false,
    interactive: false,
    write: false,
    writeToFile: null,
    diff: false,
    diffHeader: '',
    diffContext: 3, // number of lines to print before and after diffs
    color: process.stdout.isTTY,
    print: (line, nl = true) => {
      process.stdout.write(line + (nl ? '\n' : ''))
    },
    error: (line, nl = true) => {
      process.stderr.write(line + (nl ? '\n' : ''))
    },
  }

  let lineRules = []
  const documentRules = []

  const argsCopy = [...args]
  const rules = []
  let arg
  while ((arg = argsCopy.shift()) != null) {
    const option = parseOption(options, arg, argsCopy)
    if (option !== undefined) {
      options = {...options, ...option}
    } else {
      rules.push(arg)
    }
  }

  // array / null input
  // array => list of files (ssed --input=file1,file2)
  // null => read files from stdin (ssed --input - )
  if (options.inputFromFile && typeof options.input !== 'string') {
    function next(file) {
      main([], {
        ...options,
        input: file,
      })
        .on('open', () => {
          if (!options.diff) {
            options.print(yellow(`ssed: ${file}`))
          }
        })
        .on('close', next)
    }

    if (options.input === null) {
      const stdin = lineStream(process.stdin)
      // treat stdin as list of files

      stdin
        .on('line', file => {
          next(file)
        })
    } else if (Array.isArray(options.input)) {
      options.input.forEach(next)
    }

    return
  }

  if (options.inputFromFile) {
    options.diffHeader = `diff ${options.input}
--- ${options.input}
+++ ssed ${args.map(escapeShell).join(' ')}`

    const file = options.input
    if (options.write && !options.writeToFile && file !== process.stdin) {
      options.writeToFile = file
    } else if (options.writeToFile) {
      options.writeToFile = options.writeToFile.replace('%', file)
    }

    options.input = fs.createReadStream(file)
  }

  for (const rule of rules) {
    const parsed = parseRuleArgs(rule)

    let lineRule, documentRule
    if ((lineRule = toLineRule(parsed))) {
      lineRules.push(lineRule)
    } else if ((documentRule = toDocumentRule(parsed))) {
      if (lineRules.length) {
        documentRules.push(documentLinesRule(lineRules))
        lineRules = []
      }

      documentRules.push(documentRule)
    } else {
      throw Error(`Invalid rule: ${rule}`)
    }
  }

  if (lineRules.length && documentRules.length) {
    documentRules.push(documentLinesRule(lineRules))
    lineRules = []
  }

  const inputStream = lineStream(options.input)
  const originalLines = []
  let lines = []

  // if (
  //   we only have line rules,
  //   no document rules,
  //   and we're not diffing the output
  // ), then: we perform a "stream edit".
  //
  // 1. create a state for the line rules
  // 2. don't store the output in lines
  // 3. output immediately
  const state = resetState()

  for (const lineRule of lineRules) {
    lineRule.before?.(state)
  }

  let linesBuffer = []
  return inputStream
    .on('line', line => {
      const original = line
      originalLines.push(original)

      linesBuffer.push(line)
      // special handling for blank lines – if the last line is blank we skip it
      if (line === '') {
        return
      }

      processLines(
        state,
        documentRules.length > 0,
        lineRules,
        options,
        lines,
        linesBuffer,
      )

      linesBuffer = []
    })
    .on('end', (keepOpen, close) => {
      if (linesBuffer.length === 1) {
        if (!options.diff && documentRules.length === 0) {
          options.print('')
        } else {
          state.lineNumber += 1
          lines.push('')
        }
      } else if (linesBuffer.length) {
        processLines(
          state,
          documentRules.length > 0,
          lineRules,
          options,
          lines,
          linesBuffer,
        )
      }

      for (const lineRule of lineRules) {
        lineRule.after?.(state)
      }

      const isLastLineBlank = lines.at(-1) === ''
      if (isLastLineBlank) {
        lines.pop()
      }

      for (const documentRule of documentRules) {
        const linesWithNumbers = lines.map((line, index) => [line, index + 1])
        lines = documentRule(linesWithNumbers, state, options)
        if (!lines?.length) {
          break
        }
      }

      const finalLines = lines ?? []
      if (isLastLineBlank) {
        finalLines.push('')
      }

      if (options.diff) {
        const linesDiff = diff(originalLines, finalLines)
        const hasDiff = !(linesDiff.length === 1 && linesDiff[0].type === 'same')
        if (hasDiff) {
          options.print(yellow(options.diffHeader, options.color))

          let inputLineNumber = 1
          let outputLineNumber = 1
          let didPrintNumbers = false
          function printLineNumbers(inputLineNumber, outputLineNumber) {
            if (!didPrintNumbers) {
              options.print(
                magenta(
                  `@@ -${inputLineNumber} +${outputLineNumber} @@`,
                  options.color,
                ),
              )

              didPrintNumbers = true
            }
          }

          linesDiff.forEach((entry, index) => {
            if (!entry.lines.length) {
              return
            }

            if (entry.type === 'same') {
              if (index === 0) {
                didPrintNumbers = false

                const printLines = entry.lines.slice(Math.max(entry.lines.length - 3, 0))
                inputLineNumber += entry.lines.length - printLines.length
                outputLineNumber += entry.lines.length - printLines.length
                printLineNumbers(inputLineNumber, outputLineNumber)
                printLines.forEach((line) => options.print(line))
                inputLineNumber += printLines.length
                outputLineNumber += printLines.length
              }
              else if (index === linesDiff.length - 1) {
                const printLines = entry.lines.slice(0, 4)
                printLineNumbers(inputLineNumber, outputLineNumber)
                inputLineNumber += entry.lines.length - printLines.length
                outputLineNumber += entry.lines.length - printLines.length
                printLines.forEach((line) => options.print(line))
                inputLineNumber += printLines.length
                outputLineNumber += printLines.length
              } else if (entry.lines.length <= 5){
                entry.lines.forEach((line) => options.print(line))
                inputLineNumber += entry.lines.length
                outputLineNumber += entry.lines.length
              } else {
                didPrintNumbers = false

                const beforeLines = entry.lines.slice(0, 3)
                const afterLines = entry.lines.slice(Math.max(entry.lines.length - 3, 0))
                beforeLines.forEach((line) => options.print(line))
                inputLineNumber += entry.lines.length - afterLines.length
                outputLineNumber += entry.lines.length - afterLines.length
                printLineNumbers(inputLineNumber, outputLineNumber)
                afterLines.forEach((line) => options.print(line))
              }

              return
            }

            entry.lines.forEach(line => {
              printLineNumbers(inputLineNumber, outputLineNumber)

              if (entry.type === 'added') {
                outputLineNumber += 1
                options.print(green(`+${line}`, options.color))
              } else if (entry.type === 'removed') {
                inputLineNumber += 1
                options.print(red(`-${line}`, options.color))
              }
            })
          })

          if (options.write) {
            if (options.interactive) {
              if (!process.stdin.isTTY) {
                options.error(
                  red(
                    `Cannot run interactively – input is coming from stdin`,
                    options.color,
                  ),
                )
                process.exit(1)
              }

              options.print(
                yellow(
                  `Write changes to ${options.writeToFile}? [Yn] `,
                  options.color,
                ),
                false,
              )
              keepOpen()

              const stdin = lineStream(process.stdin)
              stdin.on('line', line => {
                if (line === '' || line === 'y' || line === 'yes') {
                  if (options.dryRun) {
                    options.error(
                      yellow(`Dry Run: ${options.writeToFile}`, options.color),
                    )
                  } else {
                    writeLinesToFile(finalLines, options.writeToFile)
                  }
                } else if (line === 'n') {
                  options.error(
                    yellow(`Skipping ${options.writeToFile}`, options.color),
                  )
                } else {
                  options.error(
                    red(`Unknown response '${line}'. Aborting`, options.color),
                  )
                  process.exit(1)
                }
                stdin.close()
                close()
              })
            } else {
              if (options.dryRun) {
                options.error(
                  yellow(`Dry Run: ${options.writeToFile}`, options.color),
                )
              } else {
                writeLinesToFile(finalLines, options.writeToFile)
              }
            }
          }
        }
      } else {
        for (const line of finalLines) {
          options.print(line)
        }
      }
    })
}

function toDelimiterRegex(delim) {
  if (delim === '{' || delim === '}') {
    return /[\{\}]/
  }

  if (delim === '[' || delim === ']') {
    return /[\[\]]/
  }

  if (delim === '(' || delim === ')') {
    return /[\(\)]/
  }

  if (delim === '<' || delim === '>') {
    return /[<>]/
  }

  return delim
}

function unescape(str) {
  return str.replace(/\\(.)/g, (_, char) => {
    if (char === 'n') {
      return '\n'
    }
    if (char === 't') {
      return '\t'
    }
    return `\\${char}`
  })
}

function parseRuleArgs(rule) {
  const command = rule.match(/^(\w+\b|\d+|!p(?:rint)?)(.)/)
  if (!command) {
    const [simpleCommand] = rule.match(/^(\w+\b|\d+|!p(?:rint)?)$/) ?? []
    if (!simpleCommand) {
      throw Error(`Invalid: ${rule}`)
    }
    return [simpleCommand, null, null, []]
  }

  const [cmd, delim] = [command[1], command[2]]
  const [, ...args] = rule
    .slice(delim.length)
    .split(toDelimiterRegex(delim))
    .map(unescape)
  const [pattern, replace, ...rest] = args

  return [cmd.toLowerCase(), pattern, replace, rest, delim]
}

function help() {
  process.stderr.write(`Usage:
  ssed [options] [rules]

About
-----
    ssed is an alternative to 'sed'. Not a drop-in replacement, but used for
    similar tasks. I wanted more familiar and modern Regex support, and have
    kept adding more functions as ssed became more and more my go-to text
    manipulation tool.

    Line rules transform on a line-by-line basis and, if only line rules are
    employed, support STDIN streaming.

    Document rules transform the entire document. STDIN is read to completion
    before document rules are executed.

    If the last line is blank, it is ignored.

Options
-------
  --diff                       Only show differences
  --no-diff                    Do not show differences

  --color                      Enable ANSI colors (true if stdout is a TTY)
  --no-color                   Disable ANSI colors

  --ls                         Read file names from standard input (\`ls | ssed --ls\`)

  --input=fromfile             Use 'fromfile' as input
  aka --input fromfile

  --input=fromfile1,fromfile2  Run against multiple files.
  aka --input fromfile1 --input fromfile2

  --write                      Write each changed file in place.
  --write=tofile               Provide a destination file name.
  --write=%.backup             '\%' is replaced with the input file.
  --no-write                   Do not write each changed file in place.

  --interactive                Ask before writing the file
  --no-interactive             Do not ask before writing the file

  --dry-run (-n)               Show which files would be affected.
  --no-dry-run                 Do not show which files would be affected.

Line Rules
----------
Line rules operate on every line. Commands 'on', 'after' and 'off' share the on/off state.

  s/search/replace (aka sub/…/…)   Replace the first instance of 'search' with 'replace'
  g/search/replace (aka gsub/…/…)  Replace every instance of 'search' with 'replace'
  t/pattern (aka take/…)           Only print the matching part of the line, or print the entire line if 'pattern' doesn't match
  1/pattern                        Only print the first group of the match
  1                                Only print the first "column" (columns are separated by whitespace)
  r/pattern (aka rm/…)             Remove the matching part of the line, or print the entire line if 'pattern' doesn't match
  cols/pattern/columns             Split the line by 'pattern' (default is /\\s+/) and print columns (comma separated numbers)

  on/pattern                       Start printing on the line where 'pattern' is matched
  off/pattern                      Stop printing on the line where 'pattern' is matched
  after/pattern                    Start printing on the line *after* 'pattern' is matched
  toggle/pattern                   Turn printing off at the matching line, then off, then on...

  p/pattern (aka print/…)          Only print lines that match 'pattern'
  k/pattern (aka kill/…)           Do not print lines that match 'pattern'
  !p/pattern (aka !print/…)        Alias for k/kill because I can't remember one (k) and always remember the other (p)

  prepend/text (aka prefix/…)
  append/text (aka suffix/…)       Adds text to the beginning (prepend) or end (append) of the line
  surround/prefix/suffix

  uniq (aka unique)                Only print unique lines
  uniq/pattern                     Only print matching lines, and only unique matches (uniqueness is determined by the matching regex)

Document Rules
--------------
  sublines/pattern/replace            For every line that matches, insert one line from replace. Remaining lines will
       (aka sl/…)                     be inserted into the last matched line. Does not do regex replacement.

  sort  sort/pattern                  Sort the lines alphabettically using localeCompare. If a pattern is provided, that part of the line will be used.
  sortn                               Sort the lines numerically (tries to be smart about scanning number)
  reverse                             Obvious
  line                                Prepend each line with the line number

  docprepend (docprefix)
  docappend (docsuffix)               Prepend, append, or surround the document (add header/footer)
  docsurround
  join  join/separator                Join lines with a space (or optional separator)

Example separators
------------------
  s/foo/bar
  s/foo/bar/
  s|foo|bar
  s{foo}bar

Line Number rules
-----------------
Using the special delimiter ':' you can apply most rules on line numbers instead of line content.
This bypasses any regular expression substitution (in case of 'sub' commands).

For example
  s:1:replace                      Replaces line 1 with the word "replace"
  p:1                              Only print line 1

Not all rules support this feature, but typically any rule that _could_ support it, _does_

Line numbers can be expressed as a single number, a range, an open range, a modulo operation, and a comma-separated list of rules
  p:1                              Only matches the line number (only matches line 1)
  p:%2                             Matches lines that are modulo-N (even lines)
  p:%2-1                           Matches lines that are modulo-N minus Y (odd lines)
  p:1,3,5                          Matches the listed line numbers (and only these)
  p:1-5                            Matches the range of number, inclusive (1,2,3,4,5)
  p:9-                             Matches the line number and all subsequent lines (lines 9 and onward)
  p:-9                             Matches lines up to and including the line number (lines 1-9)
  p:1-5,10-15,20,30+               Ranges and single lines can be mixed and matched

`)
}

function resetState() {
  return {
    // line-commands `on`, `after`, and `off` all share this value; toggles printing on/off
    printOn: null,
    lineNumber: 0,
  }
}

function ansi(code, input) {
  return `\x1b[${code}m${input}\x1b[0m`
}

function red(input, enabled) {
  return enabled ? ansi('1;31', input) : input
}

function green(input, enabled) {
  return enabled ? ansi('1;32', input) : input
}

function yellow(input, enabled) {
  return enabled ? ansi('38;5;227', input) : input
}

function magenta(input, enabled) {
  return enabled ? ansi('1;35', input) : input
}

function escapeShell(arg) {
  if (arg.match(/[;\\]/)) {
    return '"' + arg.replaceAll('\\', '\\\\').replaceAll('"', '\\"') + '"'
  }

  return arg
}

function writeLinesToFile(lines, file) {
  if (!file) {
    return
  }

  const output = lines.join('\n')
  fs.writeFileSync(file, output)
}

function diff(oldLines, newLines) {
  const result = [];
  let oldIndex = 0;
  let newIndex = 0;

  while (oldIndex < oldLines.length || newIndex < newLines.length) {
    if (oldIndex >= oldLines.length) {
      // All remaining lines in newLines are additions
      result.push({ type: 'added', lines: newLines.slice(newIndex) });
      break;
    }

    if (newIndex >= newLines.length) {
      // All remaining lines in oldLines are removals
      result.push({ type: 'removed', lines: oldLines.slice(oldIndex) });
      break;
    }

    if (oldLines[oldIndex] === newLines[newIndex]) {
      // Lines are the same
      let sameCount = 0;
      while (oldIndex + sameCount < oldLines.length &&
             newIndex + sameCount < newLines.length &&
             oldLines[oldIndex + sameCount] === newLines[newIndex + sameCount]) {
        sameCount++;
      }
      result.push({ type: 'same', lines: oldLines.slice(oldIndex, oldIndex + sameCount) });
      oldIndex += sameCount;
      newIndex += sameCount;
    } else {
      // Lines are different
      let oldDiffStart = oldIndex;
      let newDiffStart = newIndex;

      while (oldIndex < oldLines.length && newLines.indexOf(oldLines[oldIndex], newDiffStart) === -1) {
        oldIndex++;
      }

      while (newIndex < newLines.length && oldLines.indexOf(newLines[newIndex], oldDiffStart) === -1) {
        newIndex++;
      }

      if (oldIndex > oldDiffStart) {
        result.push({ type: 'removed', lines: oldLines.slice(oldDiffStart, oldIndex) });
      }

      if (newIndex > newDiffStart) {
        result.push({ type: 'added', lines: newLines.slice(newDiffStart, newIndex) });
      }
    }
  }

  return result;
}
try {
  // remove 'node' and 'ssed' from argv
  main(process.argv.slice(2))
} catch (e) {
  process.stderr.write(`ssed: ${e.message}\n`)
}
